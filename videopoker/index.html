<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Stealth Grid + Custom Deck — 8×8, Sprites & FOV</title>
<style>
  :root{
    --bg:#0b0e12; --panel:#11161b; --ink:#cfe3ef; --muted:#8aa2b3; --accent:#9fc46b; --danger:#ff7a7a; --gold:#d9b36a;
    --fov:#a39e5f;
    --wrap: 920px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font:14px/1.55 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    display:flex; align-items:center; justify-content:center; padding:16px;
    flex-direction:column; gap:20px;
  }
  .app{display:flex; flex-direction:column; align-items:center; gap:20px}

  .controls{display:flex; gap:8px; flex-wrap:wrap; justify-content:center}
  button{
    background:var(--panel); color:var(--ink); border:1px solid #2a3540; border-radius:12px; padding:10px 12px;
    cursor:pointer; transition:transform .05s ease, box-shadow .15s ease, border-color .15s ease;
  }
  button:hover{border-color:#3b4b59}
  button:active{transform:translateY(1px)}

  .grid{
    width:600px; height:600px;
    display:grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr);
    gap:2px; background:var(--panel); border:1px solid #26313a; border-radius:8px; padding:4px;
  }
  .cell{
    position:relative;
    display:flex; align-items:center; justify-content:center;
    border:1px solid #2f3b47; color:var(--muted);
    font-size:12px; border-radius:4px; overflow:hidden;
  }
  .floor{background:#b0b0b0}
  .start{background:#6b8f71}
  .extraction{background:#8f6b6b}
  .wall{background:#444}

  .fov{position:absolute; inset:0; background:var(--fov); opacity:.35; pointer-events:none}
  .entity{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:56px; line-height:1; color:black; font-weight:bold}
  .player{ z-index:3 }
  .guard{ z-index:3 }

  .table{background:transparent; border:none; padding:0}
  .hand{display:flex; gap:14px; align-items:flex-end; justify-content:center; flex-wrap:wrap; min-height:220px}

  .card{
    width:120px; height:170px; border-radius:14px; background:#fff; color:#111;
    border:2px solid #d6d6d6; box-shadow:0 4px 10px rgba(0,0,0,.25);
    position:relative; user-select:none;
    display:grid; grid-template-rows: 1fr auto 1fr; place-items:center;
  }
  .card.red{color:#b00020}
  .card .rank{font-weight:700; font-size:22px}
  .card .suit{font-size:26px}
  .card .pips{font-size:40px; opacity:.08; letter-spacing:2px}
  .card .corner{position:absolute; left:8px; top:6px; display:flex; flex-direction:column; align-items:center}
  .card .corner.bottom{left:auto; right:8px; top:auto; bottom:6px; transform:rotate(180deg)}
  .empty{width:120px; height:170px; border-radius:14px; border:2px dashed #3a4652; display:grid; place-items:center; color:var(--muted)}
</style>
</head>
<body>
  <div class="app" id="app">
    <div class="controls">
      <button id="btnShuffleRedraw">Shuffle Deck & Redraw Hand</button>
    </div>

    <div class="grid" id="grid"></div>

    <div class="table">
      <div class="hand" id="hand"></div>
    </div>
  </div>

<script>
(function(){
  const SUITS = ["𓀟","𓀅","𓀝","𓀎"]; // MOVE, BLOCK, MELEE, RANGED
  const RANKS = ["A","2","3"];
  const N = 8;

  const state = { deck: [], discard: [], hand: [], tiles: [], start:[7,0], exit:[0,0], player:[7,0], guards:[], fov:new Set() };

  const el = (sel)=> document.querySelector(sel);
  const key = (r,c)=> `${r},${c}`;
  const inBounds = (r,c)=> r>=0 && c>=0 && r<N && c<N;
  const cheb = (a,b)=> Math.max(Math.abs(a[0]-b[0]), Math.abs(a[1]-b[1]));
  function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }
  function freshDeck(){
    const deck=[];
    for(const s of SUITS){
      for(const r of RANKS){
        deck.push({id:`${r}${s}`,rank:r,suit:s});
      }
    }
    return shuffle(deck);
  }
  function ensureDrawCapacity(n){ if(state.deck.length>=n) return; if(!state.discard.length) return; state.deck.push(...state.discard); state.discard.length=0; shuffle(state.deck); }

  const handEl = el('#hand');
  function renderHand(){
    handEl.innerHTML='';
    state.hand.forEach(card=>{
      const d=document.createElement('div'); d.className='card';
      const tl=document.createElement('div'); tl.className='corner'; tl.innerHTML=`<div class=\"rank\">${card.rank}</div><div class=\"suit\">${card.suit}</div>`;
      const ct=document.createElement('div'); ct.className='pips'; ct.textContent=card.suit.repeat(3);
      const br=document.createElement('div'); br.className='corner bottom'; br.innerHTML=`<div class=\"rank\">${card.rank}</div><div class=\"suit\">${card.suit}</div>`;
      d.appendChild(tl); d.appendChild(ct); d.appendChild(br);
      handEl.appendChild(d);
    });
    for(let i=state.hand.length;i<4;i++){
      const e=document.createElement('div'); e.className='empty'; e.textContent='— empty —'; handEl.appendChild(e);
    }
  }
  function dealNewHand(){ state.hand.length=0; ensureDrawCapacity(4); while(state.hand.length<4 && state.deck.length){ state.hand.push(state.deck.pop()); } renderHand(); }
  function shuffleDeckAndRedraw(){ state.deck.push(...state.hand, ...state.discard); state.hand.length=0; state.discard.length=0; shuffle(state.deck); dealNewHand(); }

  function generateTiles(){
    state.tiles = Array.from({length:N},()=>Array.from({length:N},()=> 'floor'));
    for(let i=0;i<N;i++){ state.tiles[0][i]='wall'; state.tiles[N-1][i]='wall'; state.tiles[i][0]='wall'; state.tiles[i][N-1]='wall'; }
    const basePattern = [[2,1],[2,2],[2,4],[2,5],[3,2],[3,5],[4,5],[5,2],[5,3],[5,5]];
    const rot = Math.floor(Math.random()*4);
    const rotate=([r,c])=> rot===1?[c,N-1-r]: rot===2?[N-1-r,N-1-c]: rot===3?[N-1-c,r]: [r,c];
    for(const [r,c] of basePattern.map(rotate)){ state.tiles[r][c]='wall'; }
    const randCol = ()=> Math.floor(Math.random()*(N-2))+1;
    const startCol = randCol(); const exitCol = randCol();
    state.start = [7,startCol]; state.exit=[0,exitCol];
    state.tiles[state.start[0]][state.start[1]]='floor';
    state.tiles[state.exit[0]][state.exit[1]]='floor';
    state.player = [...state.start];
    state.guards = [];
    const isGoodGuardSpot = (r,c)=> state.tiles[r][c]==='floor' && cheb([r,c],state.player)>2 && cheb([r,c],state.exit)>2 && state.guards.every(g=> cheb([r,c],g)>2);
    let safety=0;
    while(state.guards.length<3 && safety<200){
      const r = Math.floor(Math.random()*N); const c = Math.floor(Math.random()*N);
      if(isGoodGuardSpot(r,c)) state.guards.push([r,c]);
      safety++;
    }
    computeFOV();
  }

  function computeFOV(){
    state.fov = new Set();
    for(const [gr,gc] of state.guards){
      for(let dr=-1; dr<=1; dr++){
        for(let dc=-1; dc<=1; dc++){
          if(dr===0 && dc===0) continue;
          const r=gr+dr, c=gc+dc; if(inBounds(r,c)) state.fov.add(key(r,c));
        }
      }
    }
  }

  function renderGrid(){
    const gridEl = el('#grid'); gridEl.innerHTML='';
    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        const cell=document.createElement('div'); cell.className='cell';
        const tile = state.tiles[r][c];
        cell.classList.add(tile);
        if(r===state.start[0] && c===state.start[1]) cell.classList.add('start');
        if(r===state.exit[0] && c===state.exit[1]) cell.classList.add('extraction');
        if(state.fov.has(key(r,c))) cell.appendChild(Object.assign(document.createElement('div'),{className:'fov'}));
        if(r===state.player[0] && c===state.player[1]){
          const e=document.createElement('div'); e.className='entity player'; e.textContent='𓀂'; cell.appendChild(e);
        }
        for(const [gr,gc] of state.guards){
          if(r===gr && c===gc){ const g=document.createElement('div'); g.className='entity guard'; g.textContent='𓀛'; cell.appendChild(g); }
        }
        gridEl.appendChild(cell);
      }
    }
  }

  const moves = { ArrowUp:[-1,0], ArrowDown:[1,0], ArrowLeft:[0,-1], ArrowRight:[0,1], w:[-1,0], s:[1,0], a:[0,-1], d:[0,1] };
  window.addEventListener('keydown', (e)=>{
    if(!(e.key in moves)) return;
    e.preventDefault();
    const [dr,dc]=moves[e.key];
    const nr=state.player[0]+dr, nc=state.player[1]+dc;
    if(!inBounds(nr,nc)) return;
    if(state.tiles[nr][nc]==='wall') return;
    state.player=[nr,nc];
    computeFOV();
    renderGrid();
  });

  el('#btnShuffleRedraw').addEventListener('click', ()=>{ shuffleDeckAndRedraw(); });

  state.deck = freshDeck(); dealNewHand();
  generateTiles(); renderGrid();
})();
</script>
</body>
</html>
