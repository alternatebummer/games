<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ASTEROIDS — Turn-Based</title>
<style>
  :root{ --bg:#0b0f14; --ink:#cfe3ef; --muted:#8aa2b3; --accent:#9fc46b; --warn:#ffb86b; --danger:#ff7a7a; }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:radial-gradient(1200px 800px at 50% 40%, #0f1520 0%, #0b0f14 60%, #070a0f 100%);
    color:var(--ink); font:14px/1.45 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    display:flex; align-items:center; justify-content:center;
  }
  #wrap{position:relative; width:min(100vw, 980px); aspect-ratio:16/9; border:1px solid #24313b; border-radius:12px; overflow:hidden; box-shadow:0 10px 40px #0008; display:flex; flex-direction:column;}
  #game-header{display:flex; justify-content:space-between; align-items:center; padding:6px 12px; background:#0e141b80; border-bottom:1px solid #22303a; z-index:2}
  #game-header h1{margin:0; font-size:14px; color:var(--muted); font-weight:600}
  #hud{display:flex; gap:12px; align-items:center}
  #hud .pill{border:1px solid #22303a; padding:4px 8px; border-radius:999px; background:#0e141b80}
  #controls{opacity:.85}
  canvas{flex:1; width:100%; height:100%;}
  #overlay{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none}
  .centercard{background:#0d141bcc; border:1px solid #22303a; padding:18px 22px; border-radius:12px; text-align:center; max-width:640px}
  .centercard h2{margin:.2em 0 .3em; font-size:18px}
  .centercard .sub{opacity:.9; text-align:left}
  .btns{display:flex; gap:10px; justify-content:center; margin-top:10px}
  button{appearance:none; border:1px solid #2a3541; background:#101821; color:var(--ink); padding:8px 12px; border-radius:8px; font:inherit; cursor:pointer}
  button:hover{border-color:#3a4a59}
  kbd{background:#101821; border:1px solid #2a3541; padding:1px 5px; border-radius:6px}
  #endTurnBtn{position:absolute; right:12px; bottom:12px; z-index:5; display:none}
</style>
</head>
<body>
  <div id="wrap">
    <div id="game-header">
      <h1>ASTEROIDS — Turn-Based</h1>
      <div id="hud">
        <span class="pill">Score: <b id="score">00000</b></span>
        <span class="pill">Lives: <b id="lives">3</b></span>
        <span class="pill">Wave: <b id="wave">1</b></span>
        <span class="pill">Phase: <b id="phase">Move</b></span>
        <span id="controls" class="pill">Mouse to act · <kbd>P</kbd> pause · <kbd>R</kbd> restart</span>
      </div>
      <button id="infoBtn" title="How to play">Info</button>
    </div>
    <canvas id="game" width="1280" height="720"></canvas>
    <button id="endTurnBtn">End Turn</button>
    <div id="overlay"></div>
  </div>

<script>
(function(){
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const waveEl  = document.getElementById('wave');
  const phaseEl = document.getElementById('phase');
  const endTurnBtn = document.getElementById('endTurnBtn');

  // --- Utils ---
  const TAU = Math.PI * 2;
  const rand = (a=1,b=0)=>Math.random()*(a-b)+b;
  const clamp=(v,min,max)=>v<min?min:v>max?max:v;
  const dist=(ax,ay,bx,by)=>Math.hypot(ax-bx,ay-by);
  const dist2=(a,b)=>{const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy};
  const W = canvas.width, H = canvas.height;

  const MAX_MOVE_DIST = 500;      // per turn cap for sanity
  const SHIP_SPEED = 220;         // px/s
  const BULLET_SPEED = 520;
  const SUBSTEP = 1/120;          // sim granularity for safe collisions

  function wrap(p){
    if (p.x < -p.r) p.x = W + p.r; else if (p.x > W + p.r) p.x = -p.r;
    if (p.y < -p.r) p.y = H + p.r; else if (p.y > H + p.r) p.y = -p.r;
  }

  function shortestDelta(ax,ay,bx,by){
    // delta from A to B on torus choosing shortest wrap
    let dx = bx - ax, dy = by - ay;
    if (Math.abs(dx) > W/2) dx -= Math.sign(dx)*W;
    if (Math.abs(dy) > H/2) dy -= Math.sign(dy)*H;
    return {dx,dy};
  }

  // Input (mouse only for phases; keep keys for pause/restart)
  const mouse = {x:0,y:0, down:false, clicked:false};
  canvas.addEventListener('mousemove', e=>{
    const r = canvas.getBoundingClientRect();
    const x = (e.clientX - r.left) * (canvas.width / r.width);
    const y = (e.clientY - r.top) * (canvas.height / r.height);
    mouse.x=x; mouse.y=y;
  });
  canvas.addEventListener('mousedown', ()=>{ mouse.down=true; });
  window.addEventListener('mouseup', ()=>{ mouse.down=false; });

  // Starfield
  const stars = Array.from({length:160}, ()=>({x:rand(W), y:rand(H), s: Math.random()<.2?2:1, a:rand(.6,.9)}));

  // Particles (thrust & explosions)
  class Particle{
    constructor(x,y,vx,vy,life,r,col){ Object.assign(this,{x,y,vx,vy,life,r,max:life,col}); this.r = r||2; }
    step(dt){ this.x+=this.vx*dt; this.y+=this.vy*dt; this.life-=dt; wrap(this); }
    draw(){ const t = clamp(this.life/this.max,0,1); ctx.save(); ctx.globalAlpha=t; ctx.fillStyle = this.col || (t>.5? '#9fc46b' : '#ffb86b'); ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,TAU); ctx.fill(); ctx.restore(); }
  }

  // Bullet
  class Bullet{
    constructor(x,y,a){
      this.x=x; this.y=y; this.a=a;
      this.vx=Math.cos(a)*BULLET_SPEED; this.vy=Math.sin(a)*BULLET_SPEED;
      this.r=2; this.life=0; this.max=0.9;
    }
    step(dt){ this.x+=this.vx*dt; this.y+=this.vy*dt; this.life+=dt; wrap(this); }
    draw(){ ctx.save(); ctx.translate(this.x,this.y); ctx.fillStyle='#cfe3ef'; ctx.beginPath(); ctx.arc(0,0,this.r,0,TAU); ctx.fill(); ctx.restore(); }
  }

  // Rock
  const ROCK_SIZES = { L: 48, M: 28, S: 16 };
  const ROCK_SCORE = { L: 20, M: 50, S: 100 };

  class Rock{
    constructor(x,y,size='L'){
      this.x=x; this.y=y; this.size=size;
      const base = {L:60,M:90,S:120}[size];
      const ang = rand(TAU);
      const spd = base + rand(40);
      this.vx=Math.cos(ang)*spd; this.vy=Math.sin(ang)*spd;
      this.a=rand(TAU); this.va=rand(-1,1);
      this.r = ROCK_SIZES[size];
      const verts = size==='L'? 12 : size==='M'? 10 : 8;
      this.shape = Array.from({length:verts},(_,i)=>{
        const t = i/verts*TAU + rand(0.25,-0.25);
        const rad = this.r*rand(1.0,0.7);
        return {x:Math.cos(t)*rad, y:Math.sin(t)*rad};
      });
    }
    step(dt){ this.x+=this.vx*dt; this.y+=this.vy*dt; this.a+=this.va*dt; wrap(this); }
    draw(){
      ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.a);
      ctx.strokeStyle='#8aa2b3'; ctx.lineWidth=2; ctx.beginPath();
      ctx.moveTo(this.shape[0].x, this.shape[0].y);
      for(let i=1;i<this.shape.length;i++) ctx.lineTo(this.shape[i].x, this.shape[i].y);
      ctx.closePath(); ctx.stroke(); ctx.restore();
    }
    split(){
      if(this.size==='L') return [new Rock(this.x,this.y,'M'), new Rock(this.x,this.y,'M')];
      if(this.size==='M') return [new Rock(this.x,this.y,'S'), new Rock(this.x,this.y,'S')];
      return [];
    }
  }

  // Ship
  class Ship{
    constructor(){
      this.x=W/2; this.y=H/2; this.vx=0; this.vy=0; this.a=-Math.PI/2;
      this.r=14; this.inv=1.5; this.blink=0;
      this.alive=true;
    }
    setAngleTo(mx,my){
      const {dx,dy} = shortestDelta(this.x,this.y,mx,my);
      this.a = Math.atan2(dy,dx);
    }
    draw(){
      ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.a);
      const ghost = (this.inv>0) && (Math.floor(this.blink)%2===0);
      ctx.strokeStyle = ghost? '#9fc46b' : '#cfe3ef';
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(16,0); ctx.lineTo(-12,10); ctx.lineTo(-8,0); ctx.lineTo(-12,-10); ctx.closePath();
      ctx.stroke();
      ctx.globalAlpha=0.25; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(20,0); ctx.stroke(); ctx.globalAlpha=1;
      ctx.restore();
    }
  }

  // Game state
  let particles=[], bullets=[], rocks=[];
  let ship = new Ship();
  let paused=false;
  let lives=3, score=0, wave=1, extraLifeAt=10000;

  const Phase = { MOVE:'Move', ANIM_MOVE:'Moving', AIM:'Aim', FIRE:'Fire', RESOLVE:'Resolve' };
  let phase = Phase.MOVE;
  let moveAnim = null;     // {t, T, sx,sy, vx,vy}
  let fireAnim = null;     // fast bullet resolve visual

  function fmtScore(n){ return n.toString().padStart(5,'0'); }
  function updateHUD(){
    scoreEl.textContent = fmtScore(score);
    livesEl.textContent = lives;
    waveEl.textContent  = wave;
    phaseEl.textContent = phase;
  }

  function circleHit(a,b){ const r=a.r+b.r; return dist2(a,b) <= r*r; }

  function spawnWave(n = 3 + (wave-1)){
    rocks.length = 0;
    for(let i=0;i<n;i++){
      // spawn away from ship
      let x,y;
      for(let t=0;t<30;t++){
        x = rand(W); y = rand(H);
        if(Math.hypot(x-ship.x, y-ship.y) > 220) break;
      }
      rocks.push(new Rock(x,y,'L'));
    }
  }

  function safeRespawn(){
    for(let t=0;t<120;t++){
      const nx=rand(W), ny=rand(H);
      const safe = rocks.every(r => Math.hypot(nx - r.x, ny - r.y) > r.r + 130);
      if(safe){
        ship = new Ship();
        ship.x=nx; ship.y=ny; ship.inv=1.5;
        return;
      }
    }
    ship = new Ship();
  }

  function explode(x,y){ for(let i=0;i<28;i++){ const a=rand(TAU); const s=rand(60,220); particles.push(new Particle(x,y,Math.cos(a)*s,Math.sin(a)*s, rand(.3,.9), rand(1,3))); } }
  function explodeSmall(x,y){ for(let i=0;i<14;i++){ const a=rand(TAU); const s=rand(40,120); particles.push(new Particle(x,y,Math.cos(a)*s,Math.sin(a)*s, rand(.2,.6), rand(1,2))); } }

  function addScore(s){
    score += s;
    if(score >= extraLifeAt){ lives++; extraLifeAt += 10000; }
    updateHUD();
  }

  // Overlay helpers
  function showOverlay(title, html, buttons){
    overlay.style.pointerEvents='auto'; overlay.innerHTML='';
    const card=document.createElement('div'); card.className='centercard';
    card.innerHTML = `<h2>${title}</h2>${html?`<div class="sub">${html}</div>`:''}`;
    const wrap=document.createElement('div'); wrap.className='btns';
    (buttons||[]).forEach(b=>{ const btn=document.createElement('button'); btn.textContent=b.label; btn.onclick=()=>{ overlay.innerHTML=''; overlay.style.pointerEvents='none'; b.onClick();}; wrap.appendChild(btn); });
    card.appendChild(wrap); overlay.appendChild(card);
  }

  function gameOver(){
    paused=true;
    showOverlay('Game Over', `Final score: <b>${fmtScore(score)}</b>`, [
      {label:'Restart', onClick:restart}
    ]);
  }

  function restart(){
    particles=[]; bullets=[]; rocks=[];
    ship = new Ship();
    lives=3; score=0; wave=1; extraLifeAt=10000;
    phase = Phase.MOVE; moveAnim=null; fireAnim=null;
    updateHUD();
    spawnWave();
    paused=false; overlay.innerHTML=''; overlay.style.pointerEvents='none';
  }

  // ----- TURN SYSTEM -----

  // 1) MOVE PHASE: click to choose destination (distance/time derived)
  canvas.addEventListener('click', ()=>{
    if(paused) return;
    if(phase!==Phase.MOVE && phase!==Phase.AIM && phase!==Phase.FIRE) return;

    if(phase===Phase.MOVE){
      const {dx,dy} = shortestDelta(ship.x, ship.y, mouse.x, mouse.y);
      let d = Math.hypot(dx,dy);
      let clamped = false;
      if(d > MAX_MOVE_DIST){ d = MAX_MOVE_DIST; clamped = true; }
      if(d < 2) return; // ignore micro-clicks

      const T = d / SHIP_SPEED; // seconds to travel
      // normalized velocity along shortest path
      const ux = dx / (Math.hypot(dx,dy)||1);
      const uy = dy / (Math.hypot(dx,dy)||1);
      moveAnim = { t:0, T, sx:ship.x, sy:ship.y, ux, uy, d };
      phase = Phase.ANIM_MOVE; updateHUD();
      endTurnBtn.style.display='none';
      if(clamped){
        // brief hint
        showHint('Move distance clamped to '+MAX_MOVE_DIST+' px');
      }
      return;
    }

    if(phase===Phase.AIM){
      // lock facing to mouse
      ship.setAngleTo(mouse.x, mouse.y);
      phase = Phase.FIRE; updateHUD();
      return;
    }

    if(phase===Phase.FIRE){
      // single shot then show End Turn
      const b = new Bullet(ship.x + Math.cos(ship.a)*16, ship.y + Math.sin(ship.a)*16, ship.a);
      bullets.push(b);
      // quick resolve: simulate the bullet until its max (with fast animation)
      fireAnim = { t:0, speed:1.0 }; // marker to run resolve visibly
      // after shot, enable end turn
      endTurnBtn.style.display='block';
      return;
    }
  });

  function showHint(text){
    const card = document.createElement('div');
    card.className='centercard';
    card.style.pointerEvents='none';
    card.innerHTML = `<div class="sub" style="text-align:center">${text}</div>`;
    overlay.appendChild(card);
    setTimeout(()=>{ if(card.parentNode) card.parentNode.removeChild(card); }, 900);
  }

  endTurnBtn.addEventListener('click', ()=>{
    if(paused) return;
    if(phase===Phase.FIRE || phase===Phase.RESOLVE){
      // cleanup bullet remnants immediately at end turn
      bullets.length = 0;
      endTurnBtn.style.display='none';
      // wave clear check
      if(rocks.length===0){
        wave++; updateHUD();
        paused=true;
        setTimeout(()=>{ spawnWave(); paused=false; phase=Phase.MOVE; updateHUD(); }, 600);
      }else{
        phase = Phase.MOVE; updateHUD();
      }
    }
  });

  // core sim step used by animations & resolve
  function simStep(dt){
    // inv timer blink
    if(ship.inv>0){ ship.inv -= dt; if(ship.inv<0) ship.inv=0; ship.blink += dt*12; }

    // rocks
    rocks.forEach(r=>r.step(dt));

    // bullets (during resolve only)
    for(let j=bullets.length-1;j>=0;j--){
      const b = bullets[j]; b.step(dt);
      // bullet vs rocks
      for(let i=rocks.length-1;i>=0;i--){
        const r = rocks[i];
        if(circleHit(r,b)){
          bullets.splice(j,1);
          explodeSmall(b.x,b.y);
          addScore(ROCK_SCORE[r.size]);
          const children = r.split();
          rocks.splice(i,1, ...children);
          break;
        }
      }
    }

    // ship vs rocks
    if(ship.alive && ship.inv<=0){
      for(const r of rocks){
        if(circleHit(ship, r)){
          ship.alive=false;
          explode(ship.x,ship.y);
          lives--; updateHUD();
          if(lives<0){ gameOver(); return; }
          setTimeout(()=>{ safeRespawn(); phase=Phase.MOVE; updateHUD(); }, 650);
          break;
        }
      }
    }
  }

  // animation drivers
  function animateMove(dt){
    if(!moveAnim) return;
    let t = moveAnim.t, T = moveAnim.T;
    // advance in fixed substeps for stable collisions
    let acc = dt;
    while(acc > 0){
      const step = Math.min(SUBSTEP, acc);
      // advance ship along direction
      const px = ship.x + moveAnim.ux * SHIP_SPEED * step;
      const py = ship.y + moveAnim.uy * SHIP_SPEED * step;
      ship.x = (px + W) % W; ship.y = (py + H) % H;
      // little thrust particles
      const bx = ship.x - moveAnim.ux*10;
      const by = ship.y - moveAnim.uy*10;
      particles.push(new Particle(bx,by, rand(-40,40)-moveAnim.ux*120, rand(-40,40)-moveAnim.uy*120, .22, 2));
      // simulate world for same step
      simStep(step);
      t += step; acc -= step;
      if(t >= T) break;
    }
    moveAnim.t = t;
    if(t >= T){
      moveAnim = null;
      phase = Phase.AIM; updateHUD();
    }
  }

  function resolveFire(dt){
    if(!fireAnim) return;
    // run sim for bullet lifetime but show quickly; bullet has its own timer
    // we just let normal draw handle bullet visuals while simStep advances it
    let acc = dt;
    let done = false;
    while(acc>0){
      const step = Math.min(SUBSTEP*2, acc);
      simStep(step);
      // if no bullets remain or all expired, end resolve
      if(bullets.length===0 || bullets.every(b=>b.life>=b.max)){ done=true; break; }
      acc -= step;
    }
    if(done){
      fireAnim = null;
      phase = Phase.RESOLVE; updateHUD();
      endTurnBtn.style.display='block';
    }
  }

  // Drawing
  function draw(){
    ctx.clearRect(0,0,W,H);
    // stars
    for(const s of stars){ ctx.globalAlpha=s.a; ctx.fillStyle='#3a4a59'; ctx.fillRect(s.x, s.y, s.s, s.s); }
    ctx.globalAlpha=1;

    // preview helpers by phase
    if(phase===Phase.MOVE){
      // distance line + clamp viz
      const {dx,dy} = shortestDelta(ship.x, ship.y, mouse.x, mouse.y);
      const d = Math.hypot(dx,dy);
      const clamped = Math.min(d, MAX_MOVE_DIST);
      const ux = (dx || 1e-6) / (d||1);
      const uy = (dy || 1e-6) / (d||1);
      const ex = ship.x + ux*clamped, ey = ship.y + uy*clamped;
      ctx.save();
      ctx.strokeStyle='#9fc46b'; ctx.lineWidth=2; ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(ship.x, ship.y); ctx.lineTo(ex, ey); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle='#9fc46b'; ctx.beginPath(); ctx.arc(ex,ey,3,0,TAU); ctx.fill();
      ctx.fillStyle='#cfe3ef';
      ctx.fillText(`Distance: ${clamped|0}px  (time ${(clamped/SHIP_SPEED).toFixed(2)}s)${d>MAX_MOVE_DIST?' — clamped':''}`, 12, 22);
      ctx.restore();
    }

    if(phase===Phase.AIM){
      // angle guide from ship to mouse
      ctx.save();
      ctx.strokeStyle='#8aa2b3'; ctx.lineWidth=2; ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(ship.x, ship.y); ctx.lineTo(mouse.x, mouse.y); ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }

    // entities
    particles.forEach(p=>p.draw());
    rocks.forEach(r=>r.draw());
    bullets.forEach(b=>b.draw());
    if(ship.alive) ship.draw();
  }

  // Pause & restart hotkeys
  window.addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if(k==='p'){
      paused=!paused; if(!paused){ overlay.innerHTML=''; overlay.style.pointerEvents='none'; }
      else { showOverlay('Paused','Press P to resume',[{label:'Resume', onClick:()=>{paused=false; overlay.innerHTML=''; overlay.style.pointerEvents='none';}}]); }
    }
    if(k==='r'){ restart(); }
  });

  // Info button
  const infoBtn = document.getElementById('infoBtn');
  if(infoBtn){
    const infoHTML = `
      <h3>Turn Structure</h3>
      <ol>
        <li><b>Move:</b> Hover to preview distance/time; click to move. The time your ship takes to move is applied to all asteroids simultaneously.</li>
        <li><b>Aim:</b> Move the mouse around your ship; click to set facing.</li>
        <li><b>Fire:</b> Click to fire once in that facing. The shot resolves immediately.</li>
        <li><b>End Turn:</b> Click the button to start your next turn.</li>
      </ol>
      <p>Wraparound playfield. Rocks split (Large→Medium→Small). Extra life every 10,000 points.</p>`;
    infoBtn.onclick = ()=>{ paused=true; showOverlay('How to Play', infoHTML, [{label:'Close', onClick:()=>{paused=false; overlay.innerHTML=''; overlay.style.pointerEvents='none';}}]); };
  }

  function update(){
    if(paused) return;

    // continuous particles aging (harmless between phases)
    const dt = Math.min(0.033, 1/60);
    particles.forEach(p=>p.step(dt));
    particles = particles.filter(p=>p.life>0);

    if(phase===Phase.ANIM_MOVE){ animateMove(dt); }
    else if(phase===Phase.FIRE || phase===Phase.RESOLVE){ resolveFire(dt); }

    // wave clear auto-advance if all rocks gone and we're not in move animation
    if(rocks.length===0 && phase!==Phase.ANIM_MOVE){
      wave++; updateHUD();
      paused=true;
      setTimeout(()=>{ spawnWave(); paused=false; phase=Phase.MOVE; updateHUD(); }, 600);
    }
  }

  // Loop
  function loop(){ update(); draw(); requestAnimationFrame(loop); }

  // Start
  function startScreen(){
    updateHUD();
    showOverlay('ASTEROIDS — Turn-Based',
      `<p>Mouse-first turns: <b>Move → Aim → Fire → End Turn</b>.</p>
       <p>Click in the field to move; click again to set facing; click to fire; then end your turn.</p>`, [
      {label:'Begin', onClick:()=>{ overlay.innerHTML=''; overlay.style.pointerEvents='none'; spawnWave(); }}
    ]);
  }

  startScreen();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
