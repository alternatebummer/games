<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ninja Assassin ‚Äî ASCII Roguelike</title>
<style>
  :root{
    --bg:#0b0e12; --panel:#11151a; --ink:#cfe3ef; --muted:#8aa2b3; --accent:#9fc46b; --danger:#ff7a7a;
    --guard-fov-bg:#705f1a; /* yellow-ish background for guard vision */
  }
  /* Layout & chrome */
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .wrap{max-width:500px;margin:0 auto;padding:16px;display:grid;gap:12px}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
  h1{margin:0;font-size:18px;color:var(--ink)}
  .hud{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .badge{background:var(--panel);border:1px solid #26313a;padding:6px 10px;border-radius:10px}
  .board{display:grid;grid-template-columns:1fr;gap:8px}
  .panel{background:var(--panel);border:1px solid #26313a;border-radius:12px;padding:12px;display:inline-block}

  /* 500√ó500 square grid container; panel will conform to this box */
  .gridWrap{width:500px;height:500px}

  /* Square-cell grid rendering */
  .grid{
    width:100%; height:100%;
    white-space:normal;      /* we will use <br> for row breaks */
    font-size:0;             /* remove gaps from whitespace/newlines */
    line-height:0;
    color:#cfe3ef;
  }
  .cell{
    display:inline-block;
    width:calc(500px / var(--W));
    height:calc(500px / var(--H));
    line-height:calc(500px / var(--H));
    text-align:center;
    vertical-align:top;
    font-weight:900;               /* very bold arrows/target */
    font-size:calc(500px / var(--H));
    transform-origin:center center; /* for rotating ‚û§ */
  }

  /* Colors & highlights */
  .gv{background:var(--guard-fov-bg)}
  .p{color:#ff4d4d}      /* player ‚û§ */
  .g{color:#ff9a3a}      /* guard ‚û§ */
  .t{color:#5ad16a}      /* target T  */

  .log{height:120px;overflow:auto}

  /* Controls */
  .controls{display:flex;gap:16px;align-items:center;flex-wrap:wrap}
  .dpad{display:grid;grid-template-columns:40px 40px 40px;grid-template-rows:40px 40px 40px;gap:6px}
  /* Keep the D-pad buttons square */
  .dpad button {
    width:40px;
    height:40px;
  }

  /* Make action buttons longer */
  .action button {
    min-width:120px;   /* adjust this number */
    height:40px;
  }


  button, .toggle{background:#131a20;color:var(--ink);border:1px solid #2a3640;border-radius:10px;padding:8px 10px;cursor:pointer}
  button:hover{border-color:#3a4854}
  .toggle{display:flex;align-items:center;gap:6px}
  .toggle input{accent-color:#9fc46b}


  /* Log text colors */
  .warn{color:#ff7a7a}.good{color:#9fc46b}.dim{color:#8aa2b3}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>üó°Ô∏è Ninja Assassin ‚Äî ASCII Roguelike</h1>
    <div class="hud">
      <div class="badge" id="floorBadge">Floor 1 / 3</div>
      <div class="badge" id="hpBadge">HP 8</div>
      <label class="toggle"><input type="checkbox" id="chkFog" checked> Fog of war</label>
      <button id="btnNew">New Run</button>
    </div>
  </header>
  <div class="panel log" id="log" aria-live="polite"></div>

  <div class="board">
    <div class="panel">
      <div class="gridWrap"><pre id="grid" class="grid" aria-label="map" role="img"></pre></div>
    </div>
    <div class="controls">
      <div class="dpad">
        <span></span><button id="btnUp" aria-label="Up">W</button><span></span>
        <button id="btnLeft" aria-label="Left">A</button><button id="btnDown" aria-label="Down">S</button><button id="btnRight" aria-label="Right">D</button>
        <span></span><span></span><span></span>
      </div>
      <div class="action">
        <button id="btnShuriken" aria-label="Throw shuriken">Shuriken (0)</button>
        <button id="btnSmoke" aria-label="Use smoke bomb">Smoke Bomb (0)</button>
      </div>
    </div>
  </div>
</div>

<script>
'use strict';
window.addEventListener('DOMContentLoaded', () => {
  // Show unexpected errors in the in-game log (works even if thrown after boot)
  window.addEventListener('error', (e)=>{
    try{ const l=document.getElementById('log'); if(l) l.insertAdjacentHTML('beforeend', `<div class="warn">JS Error: ${e.message}</div>`);}catch(err){}
  });

  // ===== Config: true square grid rendered into 500x500 =====
  const SIZE = 40; // logical grid (SIZE x SIZE)
  const W = SIZE, H = SIZE;
  const FLOORS = 3;

  // ===== Utility =====
  const rnd = (n) => Math.floor(Math.random()*n);
  const choice = (arr) => arr[rnd(arr.length)];

  // ===== Tiles =====
  const TILES = { WALL:'#', FLOOR:'.', STAIRS:'>', SHURIKEN:'*', SMOKE:'~', TARGET:'T' };

  // ===== State =====
  const state = {
    floor: 1, hp: 8,
    shuriken: 2, smoke: 1,
    smokeTurns: 0,
    map: [], seenMask: [], fog: true,
    px: 0, py: 0, lastDx: 1, lastDy: 0,
    guards: [], // {x,y,dir:[dx,dy],patrolTimer:int}
    target: null,
  };

  const DIRS = { up:[0,-1], down:[0,1], left:[-1,0], right:[1,0] };
  const DIRDEG = (d)=> (d[0]===1&&d[1]===0)?0 : (d[0]===0&&d[1]===1)?90 : (d[0]===-1&&d[1]===0)?180 : -90;

  // ===== Map Gen =====
  function makeEmpty(){ return Array.from({length:H},()=>Array.from({length:W},()=>TILES.WALL)); }
  function carveRoom(m, x,y,w,h){
    x=Math.max(1,Math.min(W-2,x)); y=Math.max(1,Math.min(H-2,y));
    w=Math.max(3,Math.min(W-2-x,w)); h=Math.max(3,Math.min(H-2-y,h));
    for(let j=y;j<y+h;j++) for(let i=x;i<x+w;i++) m[j][i]=TILES.FLOOR;
  }
  function overlaps(r, rooms){ return rooms.some(R => !(r.x+r.w+1 < R.x || R.x+R.w+1 < r.x || r.y+r.h+1 < R.y || R.y+R.h+1 < r.y)); }
  function line(m, x1,y1, x2,y2){ let x=x1,y=y1; while(x!==x2){ m[y][x]=TILES.FLOOR; x += (x2>x)?1:-1; } while(y!==y2){ m[y][x]=TILES.FLOOR; y += (y2>y)?1:-1; } m[y][x]=TILES.FLOOR; }

  function genMap(finalFloor){
    const m = makeEmpty();
    const rooms = [];
    const attempts = 160;
    for(let k=0;k<attempts;k++){
      const w= rnd(10)+5, h=rnd(6)+4;
      const x= rnd(W-w-2)+1, y=rnd(H-h-2)+1;
      const r={x,y,w,h};
      if(!overlaps(r, rooms)) { carveRoom(m,x,y,w,h); rooms.push(r); }
    }
    if(rooms.length===0){ // fallback room in the center
      carveRoom(m, Math.floor(W/2-5), Math.floor(H/2-3), 10, 6);
      rooms.push({x:Math.floor(W/2-5),y:Math.floor(H/2-3),w:10,h:6});
    }
    rooms.sort((a,b)=>a.x+a.y - (b.x+b.y));
    for(let i=1;i<rooms.length;i++){
      const a=rooms[i-1], b=rooms[i];
      line(m, Math.floor(a.x+a.w/2), Math.floor(a.y+a.h/2), Math.floor(b.x+b.w/2), Math.floor(b.y+b.h/2));
    }
    function place(tile, n){ let c=0; let guard=0; while(c<n && guard<5000){ const x=rnd(W), y=rnd(H); guard++; if(m[y][x]===TILES.FLOOR){ m[y][x]=tile; c++; } } }
    place(TILES.SHURIKEN, 3); place(TILES.SMOKE, 2);

    let placed=false; let watchdog=0; while(!placed && watchdog++<5000){ const x=rnd(W), y=rnd(H); if(m[y][x]===TILES.FLOOR){ m[y][x]= finalFloor? TILES.TARGET : TILES.STAIRS; placed=true; }}

    const guards=[]; let gcount = 5 + rnd(3); const dirChoices=[DIRS.up,DIRS.down,DIRS.left,DIRS.right];
    let guardWatch=0; while(gcount>0 && guardWatch++<10000){ const x=rnd(W), y=rnd(H); if(m[y][x]===TILES.FLOOR){ guards.push({x,y,dir:choice(dirChoices),patrolTimer:rnd(6)+3}); gcount--; }}

    let px=1, py=1; if(rooms[0]){ px=Math.floor(rooms[0].x+rooms[0].w/2); py=Math.floor(rooms[0].y+rooms[0].h/2); }
    // final fallback: find any floor tile
    if(m[py]?.[px]!==TILES.FLOOR){ outer: for(let yy=0;yy<H;yy++) for(let xx=0;xx<W;xx++) if(m[yy][xx]===TILES.FLOOR){ px=xx; py=yy; break outer; } }

    return {m, guards, px, py};
  }

  // ===== Helpers =====
  const inBounds=(x,y)=> x>=0 && y>=0 && x<W && y<H;

  function tilesInGuardFOV(g){
    const out=[]; let x=g.x, y=g.y; for(let r=1;r<=4;r++){
      x+=g.dir[0]; y+=g.dir[1]; if(!inBounds(x,y)) break; const t=state.map[y][x];
      if(t===TILES.WALL) break; out.push([x,y]);
    }
    return out;
  }

  // ===== Player FOV =====
  function revealAll(){ state.seenMask = Array.from({length:H},()=>Array.from({length:W},()=>true)); }
  function fov(){
    if(!state.fog){ revealAll(); return; }
    const R=7; const seen = Array.from({length:H},()=>Array.from({length:W},()=>false));
    for(let dy=-R; dy<=R; dy++){
      for(let dx=-R; dx<=R; dx++){
        const tx=state.px+dx, ty=state.py+dy; if(!inBounds(tx,ty)) continue; if(dx*dx+dy*dy>R*R) continue;
        const steps = Math.max(Math.abs(dx), Math.abs(dy));
        const stepx = dx/steps || 0, stepy = dy/steps || 0;
        let cx=state.px, cy=state.py;
        for(let s=0; s<=steps; s++){
          const ix=Math.round(cx), iy=Math.round(cy); if(!inBounds(ix,iy)) break;
          seen[iy][ix]=true; if(state.map[iy][ix]===TILES.WALL) break; cx += stepx; cy += stepy;
        }
      }
    }
    state.seenMask = seen;
  }

  function guardSeesPlayer(g){
    if(state.smokeTurns>0) return false;
    let x=g.x, y=g.y; for(let r=1;r<=4;r++){
      x+=g.dir[0]; y+=g.dir[1]; if(!inBounds(x,y)) break;
      const t=state.map[y][x]; if(t===TILES.WALL) return false;
      if(x===state.px && y===state.py) return true;
    }
    return false;
  }

  // ===== Rendering (square cells) =====
  function render(){
    fov();
    const grid = document.getElementById('grid'); if(!grid) return;
    // feed CSS with logical size so each .cell can size itself
    grid.style.setProperty('--W', W);
    grid.style.setProperty('--H', H);

    // highlight tiles (only for visible guards)
    const highlight = new Set();
    for(const g of state.guards){
      if(state.fog && !(state.seenMask[g.y] && state.seenMask[g.y][g.x])) continue;
      for(const [hx,hy] of tilesInGuardFOV(g)) highlight.add(hy*W+hx);
    }

    // pre-index guards for faster lookup
    const guardIndex = new Map();
    for(const g of state.guards) guardIndex.set(g.y*W+g.x, g);

    let html='';
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const visible = !state.fog || (state.seenMask[y] && state.seenMask[y][x]);
        const key=y*W+x;
        if(!visible){ html += '<span class="cell"> </span>'; continue; }

        const guardHere = guardIndex.get(key);
        const isPlayer = (state.px===x && state.py===y);
        const isTarget = (state.target && state.target.x===x && state.target.y===y);
        const isHL = highlight.has(key);

        if(isPlayer){ const deg = DIRDEG([state.lastDx,state.lastDy]); html += `<span class="cell p${isHL?' gv':''}" style="transform:rotate(${deg}deg)">‚û§</span>`; continue; }
        if(guardHere){ const deg = DIRDEG(guardHere.dir); html += `<span class="cell g${isHL?' gv':''}" style="transform:rotate(${deg}deg)">‚û§</span>`; continue; }
        if(isTarget){ html += `<span class="cell t${isHL?' gv':''}">T</span>`; continue; }

        const ch = state.map[y][x];
        const safeCh = (ch+'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
        html += (isHL && ch!=='#') ? `<span class="cell gv">${safeCh}</span>` : `<span class="cell">${safeCh}</span>`;
      }
      html += '<br/>';
    }
    grid.innerHTML = html;

    const fb=document.getElementById('floorBadge'); if(fb) fb.textContent = `Floor ${state.floor} / ${FLOORS}`;
    const hb=document.getElementById('hpBadge'); if(hb) hb.textContent = `HP ${state.hp}`;
    const bs=document.getElementById('btnShuriken'); if(bs) bs.textContent = `Shuriken (${state.shuriken})`;
    const bm=document.getElementById('btnSmoke'); if(bm) bm.textContent = `Smoke Bomb (${state.smoke})`;
  }

  const logEl = document.getElementById('log');
  function log(msg, cls=''){
    if(!logEl) return; const div=document.createElement('div'); if(cls) div.className=cls; div.textContent=msg; logEl.appendChild(div); logEl.scrollTop=logEl.scrollHeight;
  }

  // ===== Gameplay =====
  function startFloor(){
    const final = (state.floor===FLOORS);
    const {m, guards, px, py} = genMap(final);
    state.map=m; state.guards=guards; state.px=px; state.py=py; state.target=null;
    if(final){ for(let y=0;y<H;y++) for(let x=0;x<W;x++) if(m[y][x]===TILES.TARGET) state.target={x,y}; log(`You have reached the inner sanctum. Find and assassinate the target.`, 'good'); }
    else { log(`Infiltrating floor ${state.floor}.`, 'dim'); }
    render();
  }

  function newRun(){
    state.floor=1; state.hp=8; state.shuriken=2; state.smoke=1; state.smokeTurns=0; state.fog = true; state.lastDx=1; state.lastDy=0;
    const fog=document.getElementById('chkFog'); if(fog) fog.checked = true;
    if(logEl) logEl.innerHTML=''; log('A moonless night. You slip over the wall...', 'dim');
    startFloor();
  }

  function tryMove(dx,dy){
    const nx=state.px+dx, ny=state.py+dy; if(!inBounds(nx,ny)) return;
    const t=state.map[ny][nx];
    if(t===TILES.WALL) return;
    state.px=nx; state.py=ny; state.lastDx=dx; state.lastDy=dy;
    postMove();
  }

  function autoPickup(){
    const t=state.map[state.py][state.px];
    if(t===TILES.SHURIKEN){ state.shuriken++; state.map[state.py][state.px]=TILES.FLOOR; log('You pocket a shuriken.'); }
    else if(t===TILES.SMOKE){ state.smoke++; state.map[state.py][state.px]=TILES.FLOOR; log('You collect a smoke bomb.'); }
  }

  function postMove(){
    autoPickup();
    if(state.smokeTurns>0){ state.smokeTurns--; if(state.smokeTurns===0) log('The smoke clears.', 'dim'); }

    for(const g of state.guards){ if(guardSeesPlayer(g)) return gameOver('A guard spots you. The alarm ends your mission.'); }

    if(state.map[state.py][state.px]===TILES.STAIRS){ state.floor++; if(state.floor>FLOORS) state.floor=FLOORS; log('You descend deeper...', 'dim'); startFloor(); return; }
    if(state.target && state.px===state.target.x && state.py===state.target.y) return win();

    guardsAct();
    render();
  }

  function gameOver(msg){ log(msg, 'warn'); log('Mission failed. Press "New Run" to try again.'); state.hp=0; render(); }
  function win(){ log('The blade finds its mark. The tyrant falls. Mission complete.', 'good'); state.hp=0; render(); }

  function throwShuriken(dx,dy){
    if(state.shuriken<=0){ log('Out of shuriken.', 'dim'); return; }
    if(dx===0 && dy===0){ dx=1; dy=0; }
    state.shuriken--;
    let x=state.px, y=state.py;
    for(let i=0;i<8;i++){
      x+=dx; y+=dy; if(!inBounds(x,y)) break; const t=state.map[y][x]; if(t===TILES.WALL) break;
      const gi= state.guards.findIndex(g=>g.x===x && g.y===y);
      if(gi>=0){ state.guards.splice(gi,1); log('A silent strike fells a guard.'); render(); return; }
      if(state.target && state.target.x===x && state.target.y===y){ log('The target collapses from afar. Mission complete.', 'good'); state.hp=0; render(); return; }
    }
    log('The shuriken whistles into the dark.', 'dim');
  }

  function smoke(){ if(state.smoke<=0){ log('No smoke bombs left.', 'dim'); return; } state.smoke--; state.smokeTurns=3; log('You vanish into smoke (3 turns).'); render(); }

  function guardsAct(){
    const dirChoices=[DIRS.up,DIRS.down,DIRS.left,DIRS.right];
    for(const g of state.guards){
      // pre-turn/step vision
      if(guardSeesPlayer(g)) return gameOver('A guard spots you. The alarm ends your mission.');

      // try step; if blocked, turn
      let nx=g.x+g.dir[0], ny=g.y+g.dir[1];
      const pass = inBounds(nx,ny) && (state.map[ny][nx]!==TILES.WALL);
      if(pass){ g.x=nx; g.y=ny; } else { g.dir = choice(dirChoices); }

      // patrol timer may also cause turn
      g.patrolTimer--; if(g.patrolTimer<=0){ g.dir = choice(dirChoices); g.patrolTimer=rnd(6)+3; }

      // post-turn/step vision (instant catch when they rotate into you)
      if(guardSeesPlayer(g)) return gameOver('A guard spots you. The alarm ends your mission.');

      // collision
      if(g.x===state.px && g.y===state.py) return gameOver('A guard bumps into you!');
    }
  }

  // ===== Input =====
  window.addEventListener('keydown', (e)=>{
    if(state.hp<=0 && e.key!=='Enter') return;
    const k=e.key.toLowerCase();
    if(k==='arrowup' || k==='w') tryMove(0,-1);
    else if(k==='arrowdown' || k==='s') tryMove(0,1);
    else if(k==='arrowleft' || k==='a') tryMove(-1,0);
    else if(k==='arrowright' || k==='d') tryMove(1,0);
    else if(k==='f') throwShuriken(state.lastDx, state.lastDy);
    else if(k==='v') smoke();
  });

  // Click controls
  const byId=(id)=>document.getElementById(id);
  byId('btnNew')?.addEventListener('click', newRun);
  byId('chkFog')?.addEventListener('change', (e)=>{ state.fog = e.target.checked; render(); });
  byId('btnUp')?.addEventListener('click', ()=>tryMove(0,-1));
  byId('btnDown')?.addEventListener('click', ()=>tryMove(0,1));
  byId('btnLeft')?.addEventListener('click', ()=>tryMove(-1,0));
  byId('btnRight')?.addEventListener('click', ()=>tryMove(1,0));
  byId('btnShuriken')?.addEventListener('click', ()=>throwShuriken(state.lastDx, state.lastDy));
  byId('btnSmoke')?.addEventListener('click', smoke);

  newRun();
});
</script>
</body>
</html>
