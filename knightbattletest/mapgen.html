<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Wilderness Roguelike — 3 Maps, 30×30 (FOV + Enemies + Neighbor FOV)</title>
<style>
  :root{
    --wrap: 500;              /* wrapper size in px (square) */
    --w: 30; --h: 30;         /* grid size (30×30) */
    --bg:#0b0e12; --ink:#cfe3ef; --muted:#8aa2b3;

    /* Tile colors */
    --path:#a36f4b;           /* . brown */
    --grass:#38452e;          /* " green (your latest) */
    --tree:#2c6a3f;           /* A dark green (impassable) */
    --rock:#6f818f;           /* a gunmetal grey (impassable) */
    --water:#3da3d5;          /* ~ blue (impassable) */
    --accent-red:#ff5a5a;     /* ➨ and both Xs (spawn + destination) */
    --player:#ffffff;         /* @ (white) */
    --enemy:#f78952;          /* enemy @ light orange */
    --enemy-fov:#f7c26f;      /* amber tint for enemy sight tiles */
  }

  *{ box-sizing:border-box }
  html,body{ height:100% }
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font:12px/1 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
    display:flex; align-items:center; justify-content:center; padding:12px;
    user-select:none;
  }

  .wrap{
    width: calc(var(--wrap) * 1px);
    display:flex; flex-direction:column; gap:8px; align-items:center;
  }

  header{
    width:100%; display:flex; justify-content:space-between; align-items:center;
    font-weight:600; color:var(--muted);
  }
  header .left{display:flex; gap:12px; align-items:center}
  header .right{font-size:12px}

  .grid{
    width: calc(var(--wrap) * 1px);
    height: calc(var(--wrap) * 1px);
    display:grid;
    grid-template-columns: repeat(var(--w), 1fr);
    grid-template-rows: repeat(var(--h), 1fr);
    border:1px solid #25303a;
    background:#0f1318;
    box-shadow:0 0 0 1px #141b22 inset, 0 4px 24px rgba(0,0,0,0.35);
    overflow:hidden;
  }

  .cell{
    display:flex; align-items:center; justify-content:center;
    font-weight:800;
    aspect-ratio: 1 / 1;

    /* largest possible glyphs without expanding the grid */
    --tight: 1.2;
    font-size: calc((var(--wrap) * 1px) / var(--w) * var(--tight));
    line-height: 1;

    /* allow shrink within tracks */
    min-width: 0;
    min-height: 0;
    overflow: hidden;
    contain: size layout paint;

    /* faint glow */
    text-shadow:
      0 0 3px currentColor,
      0 0 3px currentColor;

    transition: opacity 80ms linear;
  }

  /* Base tile classes (color only) */
  .t-path   { color: var(--path); }
  .t-grass  { color: var(--grass); }
  .t-tree   { color: var(--tree); }
  .t-rock   { color: var(--rock); }
  .t-water  { color: var(--water); }
  .t-arrow  { color: var(--accent-red); transform: rotate(-90deg); } /* ➨ red, up */
  .t-x      { color: var(--accent-red); }   /* red X (spawn + destination) */
  .t-player { color: var(--player); }       /* @ */
  .t-enemy  { color: var(--enemy); }        /* enemy @ (light orange) */
  .t-efov   { color: var(--enemy-fov) !important; } /* amber cone tint */

  /* Fog of War */
  .fog-unseen { color:#13181d !important; opacity:1 !important; }
  .fog-seen   { opacity:.20; }

  .legend{
    width:100%;
    display:flex; flex-wrap:wrap; gap:10px; justify-content:center;
    color:#8da2b2; font-size:12px;
  }
  .legend b{color:#cfe3ef}
  .msg{ color:#9fc46b; font-weight:600 }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="left">
      <div>Wilderness Roguelike</div>
      <div>• <span id="level">Map 1/3</span></div>
    </div>
    <div class="right">
      Move: <b>W A S D</b> • Restart: <b>R</b> • Fog: <b>F</b>
    </div>
  </header>

  <div id="grid" class="grid" aria-label="map grid"></div>

  <div class="legend">
    <span><b>@</b> you (white)</span>
    <span><b>@</b> enemy (light orange)</span>
    <span>amber cells = enemy sight (adjacent 8)</span>
    <span><b>X</b> spawn & destination (red)</span>
    <span><b>.</b> path (brown)</span>
    <span><b>"</b> grass (green)</span>
    <span><b>A</b> tree (dark green, ❌)</span>
    <span><b>a</b> boulder (gunmetal, ❌)</span>
    <span><b>~</b> water (blue, ❌)</span>
    <span><b>➨</b> arrow (red, up) → next map</span>
    <span class="msg" id="msg"></span>
  </div>
</div>

<script>
(() => {
  "use strict";

  // ===== Config =====
  const W = 30, H = 30, MAPS = 3;
  const gridEl = document.getElementById("grid");
  const levelEl = document.getElementById("level");
  const msgEl = document.getElementById("msg");

  // ===== Helpers =====
  const rnd = (n)=> Math.floor(Math.random()*n);
  const choice = (arr)=> arr[rnd(arr.length)];
  const inBounds = (x,y)=> x>=0 && y>=0 && x<W && y<H;

  // ===== Tiles =====
  const TILES = {
    GRASS:  '"',
    TREE:   'A',
    STONE:  'a',
    DIRT:   '.',
    WATER:  '~',
    ARROW:  '➨',
    DEST:   'X',
    SPAWN:  'X',
    PLAYER: '@'
  };

  const CLASS = {
    '"': 't-grass',
    'A': 't-tree',
    'a': 't-rock',
    '.': 't-path',
    '~': 't-water',
    '➨': 't-arrow',
    'X': 't-x',
    '@': 't-player'
  };

  const PASSABLE = new Set(['.', '"', '➨', 'X', '@']); // path/grass/arrow/dest/spawn
  const isBlocked = (ch)=> (ch==='A' || ch==='a' || ch==='~'); // blocks movement + vision
  const isWalkableForEnemy = (ch)=> (ch==='.' || ch==='"');

  // ===== DOM: build once =====
  let cells = [];
  function buildGridDOM(){
    let html = "";
    for(let i=0;i<W*H;i++) html += '<div class="cell"></div>';
    gridEl.innerHTML = html;

    const flat = Array.from(gridEl.children);
    cells = new Array(H);
    for(let y=0;y<H;y++){
      cells[y] = new Array(W);
      for(let x=0;x<W;x++){
        cells[y][x] = flat[y*W + x];
      }
    }
  }

  // ===== Smooth edge→center→edge forest density + meandering trail + water =====
  function genTrailMap(finalPart=false){
    const m = Array.from({length:H},()=>Array.from({length:W},()=>TILES.GRASS));
    const cx = Math.floor(W/2);

    // Gradient forest
    for(let y=1;y<H-1;y++){
      for(let x=1;x<W-1;x++){
        const d = Math.abs(x - cx) / (W/2);                   // 0 center → 1 edge
        const treeP = Math.max(0, Math.pow(d, 1.5) * 0.70 + 0.04);
        const rockP = Math.pow(d, 1.2) * 0.05;
        const r = Math.random();
        if (r < treeP) m[y][x] = TILES.TREE;
        else if (r < treeP + rockP) m[y][x] = TILES.STONE;
      }
    }

    // Dense borders (4–6 cols)
    const borderL = 4 + rnd(3), borderR = 4 + rnd(3);
    for(let y=0;y<H;y++){
      for(let x=0;x<borderL;x++) m[y][x] = TILES.TREE;
      for(let x=W-borderR;x<W;x++) m[y][x] = TILES.TREE;
    }

    // Meandering trail bottom→top
    let tx = rnd(W-10)+5;
    let ty = H-2;
    const startX = tx;
    while(ty>1){
      m[ty][tx] = TILES.DIRT;
      if(Math.random()<0.25 && tx+1<W-1) m[ty][tx+1] = TILES.DIRT;
      if(Math.random()<0.25 && tx-1>0)   m[ty][tx-1] = TILES.DIRT;
      const dx = choice([-1,0,1,0]);
      tx = Math.max(1, Math.min(W-2, tx+dx));
      ty = ty - 1;
      m[ty][tx] = TILES.DIRT;
    }

    // Water pools 1–3, size 3–6
    const pools = 1 + rnd(3);
    for(let p=0;p<pools;p++){
      const size = 3 + rnd(4);
      let sx=0, sy=0, tries=0;
      do { sx = rnd(W-2)+1; sy = rnd(H-2)+1; tries++; }
      while(m[sy][sx]===TILES.DIRT && tries<100);

      const pool = [];
      const ok = (x,y)=> m[y][x]!==TILES.DIRT && m[y][x]!==TILES.ARROW && m[y][x]!==TILES.DEST && m[y][x]!==TILES.SPAWN;
      pool.push([sx,sy]);
      while(pool.length<size){
        const [px,py] = pool[rnd(pool.length)];
        const step = [[1,0],[-1,0],[0,1],[0,-1]][rnd(4)];
        const nx=px+step[0], ny=py+step[1];
        if(inBounds(nx,ny) && ok(nx,ny)) pool.push([nx,ny]);
        if(pool.length>size*2) break;
      }
      for(const [wx,wy] of pool){
        if(m[wy][wx]!==TILES.DIRT) m[wy][wx] = TILES.WATER;
      }
    }

    // Spawn X (bottom) and exit/destination (top)
    m[H-2][startX] = TILES.SPAWN;
    let topX = tx;
    for(let sx=0; sx<W; sx++){
      const cand = Math.max(1, Math.min(W-2, tx + (sx%2 ? -Math.ceil(sx/2) : Math.ceil(sx/2))));
      if(m[1][cand]===TILES.DIRT){ topX = cand; break; }
    }
    m[1][topX] = finalPart ? TILES.DEST : TILES.ARROW;

    return m;
  }

  // ===== ENEMIES =====
  const DIRS = { up:[0,-1], down:[0,1], left:[-1,0], right:[1,0] };
  const dirChoices = [DIRS.up, DIRS.down, DIRS.left, DIRS.right];

  function spawnEnemiesForCurrentMap(){
    const part = state.mapIndex + 1; // 1..3
    const enemies = [];
    let ecount = 8 + (part-1)*3 + rnd(3); // 8–10, 11–13, 14–16
    let guard = 0;

    const bottomY = H-2;
    let bottomX = -1;
    for(let x=1;x<W-1;x++){ if(state.map[bottomY][x]==='X'){ bottomX=x; break; } }
    const topY = 1;
    let topMarkerX = -1;
    for(let x=1;x<W-1;x++){ if(state.map[topY][x]==='➨' || state.map[topY][x]==='X'){ topMarkerX=x; break; } }

    while(ecount>0 && guard++<12000){
      const ex=rnd(W), ey=rnd(H);
      const t = inBounds(ex,ey) ? state.map[ey][ex] : '#';
      const farFromMarkers = !(ey===bottomY && ex===bottomX) && !(ey===topY && ex===topMarkerX);
      const open = (t===TILES.DIRT || t===TILES.GRASS);
      const empty = enemies.every(e => !(e.x===ex && e.y===ey));
      if(open && farFromMarkers && empty){
        enemies.push({x:ex,y:ey,dir:choice(dirChoices),patrolTimer:rnd(6)+3});
        ecount--;
      }
    }
    state.enemies = enemies;
  }

  // Adjacent (8) tiles as enemy FOV
  function tilesInEnemyFOV(g){
    const out=[];
    for(let dy=-1; dy<=1; dy++){
      for(let dx=-1; dx<=1; dx++){
        if(dx===0 && dy===0) continue;
        const x = g.x + dx, y = g.y + dy;
        if(inBounds(x,y)) out.push([x,y]);
      }
    }
    return out;
  }

  function enemySeesPlayer(g){
    // With neighbor-FOV, "sees" means player is in the adjacent ring
    for(const [x,y] of tilesInEnemyFOV(g)){
      if(x===state.px && y===state.py) return true;
    }
    return false;
  }

  function occupiedByEnemy(nx,ny){
    return state.enemies.some(e => e.x===nx && e.y===ny);
  }

  function stepEnemies(){
    if(state.gameOver) return;
    for(const g of state.enemies){
      // patrol timer / turn
      g.patrolTimer--;
      if(g.patrolTimer<=0 || Math.random()<0.15){
        g.dir = choice(dirChoices);
        g.patrolTimer = rnd(6)+3;
      }

      // chase only if player is in adjacent FOV (move towards player if possible)
      let moved = false;
      if(enemySeesPlayer(g)){
        const dx = Math.sign(state.px - g.x);
        const dy = Math.sign(state.py - g.y);
        const trySteps = dx && dy ? [[dx,0],[0,dy],[dx,dy]] : [[dx,dy]];
        for(const [sx,sy] of trySteps){
          const nx = g.x + sx, ny = g.y + sy;
          if(inBounds(nx,ny) && isWalkableForEnemy(state.map[ny][nx]) && !occupiedByEnemy(nx,ny)){
            g.x = nx; g.y = ny; moved = true; break;
          }
        }
      }

      // otherwise continue forward or reroll dir
      if(!moved){
        const nx = g.x + g.dir[0];
        const ny = g.y + g.dir[1];
        if(inBounds(nx,ny) && isWalkableForEnemy(state.map[ny][nx]) && !occupiedByEnemy(nx,ny)){
          g.x = nx; g.y = ny;
        }else{
          g.dir = choice(dirChoices);
        }
      }

      // collision with player
      if(g.x===state.px && g.y===state.py){
        state.gameOver = true;
        msg("Tagged by a ranger! Press R to restart.");
      }
    }
  }

  // ===== FOV / Fog of War =====
  const state = {
    mapIndex: 0,
    fog: true,
    map: null,
    px: 0, py: 0,
    seenMask: null,
    visMask: null,
    enemies: [],
    gameOver: false,
  };

  function makeMask(val=false){
    return Array.from({length:H},()=>Array.from({length:W},()=>val));
  }

  function revealAll(){
    state.seenMask = makeMask(true);
    state.visMask  = makeMask(true);
  }

  function fov(){
    if(!state.fog){ revealAll(); return; }
    const R = 7;
    const seen = makeMask(false);
    for(let dy=-R; dy<=R; dy++){
      for(let dx=-R; dx<=R; dx++){
        const tx = state.px + dx, ty = state.py + dy;
        if(!inBounds(tx,ty)) continue;
        if(dx*dx + dy*dy > R*R) continue;

        const steps = Math.max(Math.abs(dx), Math.abs(dy));
        const stepx = dx/steps || 0;
        const stepy = dy/steps || 0;
        let cx = state.px, cy = state.py;

        for(let s=0; s<=steps; s++){
          const ix = Math.round(cx), iy = Math.round(cy);
          if(!inBounds(ix,iy)) break;
          seen[iy][ix] = true;
          if(isBlocked(state.map[iy][ix])) break;
          cx += stepx; cy += stepy;
        }
      }
    }
    state.visMask = seen;
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        if(seen[y][x]) state.seenMask[y][x] = true;
      }
    }
  }

  // ===== Rendering =====
  function paintFrame(){
    // Build union of enemy FOV tiles (adjacent 8)
    const efovMask = makeMask(false);
    for(const g of state.enemies){
      for(const [x,y] of tilesInEnemyFOV(g)){
        if(inBounds(x,y)) efovMask[y][x] = true;
      }
    }

    // Base tiles + fog + enemy FOV tint
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const base = state.map[y][x];
        const el = cells[y][x];

        el.className = "cell " + (CLASS[base] || 't-grass');
        el.textContent = base;

        if(state.fog){
          const visible = state.visMask[y][x];
          const seen = state.seenMask[y][x];
          if(!seen){
            el.classList.add('fog-unseen');
          } else if(!visible){
            el.classList.add('fog-seen');
          }
          // Show enemy FOV highlight only when currently visible to the player
          if(visible && efovMask[y][x]){
            el.classList.add('t-efov');
          }
        } else {
          if(efovMask[y][x]){
            el.classList.add('t-efov');
          }
        }
      }
    }

    // draw visible enemies (after tiles/fog/tint)
    for(const g of state.enemies){
      if(state.visMask[g.y]?.[g.x]){
        const el = cells[g.y][g.x];
        el.className = "cell t-enemy";
        el.textContent = '@';
      }
    }

    // player last
    const pel = cells[state.py][state.px];
    pel.className = "cell t-player";
    pel.textContent = TILES.PLAYER;
  }

  // ===== Game State / Flow =====
  let maps = [];

  function msg(s){ msgEl.textContent = s || ""; }

  function initAll(){
    maps = [ genTrailMap(false), genTrailMap(false), genTrailMap(true) ];
    state.mapIndex = 0;
    state.gameOver = false;
    loadMap(state.mapIndex, true);
    msg("");
  }

  function loadMap(idx, placePlayer){
    state.map = maps[idx];
    state.gameOver = false;

    // player at bottom spawn X
    let px = 1, py = H-2;
    for(let x=1;x<W-1;x++){
      if(state.map[H-2][x]==='X'){ px=x; break; }
    }
    if(placePlayer){ state.px = px; state.py = py; }

    // reset fog and enemies
    state.seenMask = makeMask(false);
    state.visMask = makeMask(false);
    spawnEnemiesForCurrentMap();
    fov();
    paintFrame();
    levelEl.textContent = `Map ${idx+1}/${MAPS}`;
  }

  // Helper: are we on any enemy FOV tile right now?
  function playerOnAnyEnemyFOV(){
    for(const g of state.enemies){
      for(const [x,y] of tilesInEnemyFOV(g)){
        if(x===state.px && y===state.py) return true;
      }
    }
    return false;
  }

  function tryMove(dx,dy){
    if(state.gameOver) return;
    const nx = Math.max(0, Math.min(W-1, state.px + dx));
    const ny = Math.max(0, Math.min(H-1, state.py + dy));

    // block walking into enemy
    if(state.enemies.some(e => e.x===nx && e.y===ny)) {
      msg("Enemy blocks the way.");
      return;
    }

    const t = state.map[ny][nx];
    if (isBlocked(t)) return;

    // move player
    state.px = nx; state.py = ny;

    // if you landed on any enemy's FOV indicator → tagged
    if (playerOnAnyEnemyFOV()){
      state.gameOver = true;
      paintFrame();
      msg("Spotted! Press R to restart.");
      return;
    }

    // Player FOV → enemy turn → check again → paint
    fov();
    stepEnemies();

    if (!state.gameOver && playerOnAnyEnemyFOV()){
      state.gameOver = true;
      paintFrame();
      msg("Spotted! Press R to restart.");
      return;
    }

    fov();
    paintFrame();

    // Interactions
    if (t === '➨'){
      if (state.mapIndex < MAPS-1){
        state.mapIndex++;
        msg(`Advancing to Map ${state.mapIndex+1}...`);
        loadMap(state.mapIndex, true);
        msg("");
      }
    } else if (t === 'X' && state.py===1){
      if (state.mapIndex === MAPS-1){
        msg("You reached the destination! Press R to restart.");
        state.gameOver = true;
      }
    }
  }

  // ===== Controls =====
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (k==="w")      tryMove( 0,-1);
    else if (k==="s") tryMove( 0, 1);
    else if (k==="a") tryMove(-1, 0);
    else if (k==="d") tryMove( 1, 0);
    else if (k==="r") initAll();
    else if (k==="f"){ state.fog = !state.fog; fov(); paintFrame(); }
  });

  // ===== Boot =====
  buildGridDOM();
  initAll();
})();
</script>
</body>
</html>
