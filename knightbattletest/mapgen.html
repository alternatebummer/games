<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Wilderness Roguelike — Brython (Fast FOV, No Enemies)</title>
<style>
  :root{
    --wrap: 500; --w: 30; --h: 30;
    --bg:#0b0e12; --ink:#cfe3ef; --muted:#8aa2b3;
    --path:#a36f4b; --grass:#38452e; --tree:#2c6a3f; --rock:#6f818f; --water:#3da3d5;
    --accent-red:#ff5a5a; --player:#ffffff;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;background:var(--bg);color:var(--ink);
    font:12px/1 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
    display:flex;align-items:center;justify-content:center;padding:12px;user-select:none;
  }
  .wrap{width:calc(var(--wrap)*1px);display:flex;flex-direction:column;gap:8px;align-items:center}
  header{width:100%;display:flex;justify-content:space-between;align-items:center;font-weight:600;color:var(--muted)}
  header .left{display:flex;gap:12px;align-items:center}
  header .right{font-size:12px}
  .grid{
    width:calc(var(--wrap)*1px);height:calc(var(--wrap)*1px);
    display:grid;grid-template-columns:repeat(var(--w),1fr);grid-template-rows:repeat(var(--h),1fr);
    border:1px solid #25303a;background:#0f1318;box-shadow:0 0 0 1px #141b22 inset,0 4px 24px rgba(0,0,0,.35);overflow:hidden;
  }
  .cell{
    display:flex;align-items:center;justify-content:center;font-weight:800;aspect-ratio:1/1;
    --tight:1.2;font-size:calc((var(--wrap)*1px)/var(--w)*var(--tight));line-height:1;
    min-width:0;min-height:0;overflow:hidden;contain:size layout paint;
    text-shadow:0 0 3px currentColor,0 0 3px currentColor;transition:opacity 80ms linear;
  }
  .t-path{color:var(--path)} .t-grass{color:var(--grass)} .t-tree{color:var(--tree)}
  .t-rock{color:var(--rock)} .t-water{color:var(--water)}
  .t-arrow{color:var(--accent-red);transform:rotate(-90deg)} .t-x{color:var(--accent-red)}
  .t-player{color:var(--player)}

  /* Fog of War — force glyphs black when covered */
  .fog-unseen { color:#000 !important; opacity:1 !important; }
  .fog-seen   { color:#000 !important; opacity:.20; }

  .legend{width:100%;display:flex;flex-wrap:wrap;gap:10px;justify-content:center;color:#8da2b2;font-size:12px}
  .legend b{color:#cfe3ef}
  .msg{color:#9fc46b;font-weight:600}
</style>
<script src="https://cdn.jsdelivr.net/npm/brython@3.12.3/brython.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/brython@3.12.3/brython_stdlib.js"></script>
</head>
<body onload="brython()">
<div class="wrap">
  <header>
    <div class="left">
      <div>Wilderness Roguelike</div>
      <div>• <span id="level">Map 1/3</span></div>
    </div>
    <div class="right">Move: <b>W A S D</b> • Restart: <b>R</b> • Fog: <b>F</b></div>
  </header>
  <div id="grid" class="grid" aria-label="map grid"></div>
  <div class="legend">
    <span><b>@</b> you (white)</span><span><b>X</b> spawn & destination (red)</span>
    <span><b>.</b> path</span><span><b>"</b> grass</span><span><b>A</b> tree ❌</span>
    <span><b>a</b> boulder ❌</span><span><b>~</b> water ❌</span><span><b>➨</b> arrow → next map</span>
    <span class="msg" id="msg"></span>
  </div>
</div>

<script type="text/python">
from browser import document, html, bind
import random, math

# ===== Config =====
W, H, MAPS = 30, 30, 3
R = 7  # FOV radius
grid_el = document["grid"]; level_el = document["level"]; msg_el = document["msg"]

# ===== Helpers =====
rnd = lambda n: random.randrange(n)
def choice(arr): return arr[rnd(len(arr))]
def in_bounds(x,y): return 0 <= x < W and 0 <= y < H

# ===== Tiles / classes =====
TILES = {"GRASS":'"',"TREE":'A',"STONE":'a',"DIRT":'.',"WATER":'~',"ARROW":'➨',"DEST":'X',"SPAWN":'X',"PLAYER":'@'}
CLASS = {'"':'t-grass','A':'t-tree','a':'t-rock','.':'t-path','~':'t-water','➨':'t-arrow','X':'t-x','@':'t-player'}
def is_blocked(ch): return ch in ('A','a','~')

# ===== DOM grid =====
cells = []
def build_grid_dom():
    grid_el.clear()
    for _ in range(W*H):
        grid_el <= html.DIV(Class="cell")
    flat = list(grid_el.children)
    del cells[:]
    for y in range(H):
        row = []
        for x in range(W):
            row.append(flat[y*W + x])
        cells.append(row)

# ===== Map gen =====
def gen_trail_map(final_part=False):
    m = [[TILES["GRASS"] for _ in range(W)] for _ in range(H)]
    cx = W//2
    for y in range(1,H-1):
        for x in range(1,W-1):
            d = abs(x-cx)/(W/2)
            treeP = max(0.0, (d**1.5)*0.70 + 0.04)
            rockP = (d**1.2)*0.05
            r = random.random()
            if r < treeP: m[y][x] = TILES["TREE"]
            elif r < treeP + rockP: m[y][x] = TILES["STONE"]
    borderL = 4 + rnd(3); borderR = 4 + rnd(3)
    for y in range(H):
        for x in range(borderL): m[y][x] = TILES["TREE"]
        for x in range(W-borderR, W): m[y][x] = TILES["TREE"]
    tx = rnd(W-10)+5; ty = H-2; startX = tx
    while ty > 1:
        m[ty][tx] = TILES["DIRT"]
        if random.random()<0.25 and tx+1 < W-1: m[ty][tx+1] = TILES["DIRT"]
        if random.random()<0.25 and tx-1 > 0:   m[ty][tx-1] = TILES["DIRT"]
        dx = choice([-1,0,1,0]); tx = max(1, min(W-2, tx+dx)); ty -= 1
        m[ty][tx] = TILES["DIRT"]
    pools = 1 + rnd(3)
    for _ in range(pools):
        size = 3 + rnd(4); tries = 0
        while True:
            sx = rnd(W-2)+1; sy = rnd(H-2)+1; tries += 1
            if m[sy][sx] != TILES["DIRT"] or tries >= 100: break
        pool = [(sx,sy)]
        def ok(x,y): return m[y][x] not in (TILES["DIRT"],TILES["ARROW"],TILES["DEST"],TILES["SPAWN"])
        while len(pool) < size:
            px,py = choice(pool); stepx,stepy = choice([(1,0),(-1,0),(0,1),(0,-1)])
            nx,ny = px+stepx, py+stepy
            if in_bounds(nx,ny) and ok(nx,ny): pool.append((nx,ny))
            if len(pool) > size*2: break
        for wx,wy in pool:
            if m[wy][wx] != TILES["DIRT"]: m[wy][wx] = TILES["WATER"]
    m[H-2][startX] = TILES["SPAWN"]
    topX = tx
    for sx in range(W):
        cand = max(1, min(W-2, tx + (-math.ceil(sx/2) if sx%2 else math.ceil(sx/2))))
        if m[1][cand] == TILES["DIRT"]: topX = cand; break
    m[1][topX] = TILES["DEST"] if final_part else TILES["ARROW"]
    return m

# ===== State =====
state = {
    "mapIndex":0, "fog":True, "map":None,
    "px":0, "py":0, "prev_px":0, "prev_py":0,
    "seenMask":None, "visMask":None, "gameOver":False
}
base_class = [[None]*W for _ in range(H)]  # 'cell t-grass' etc.

def make_mask(val=False): return [[val for _ in range(W)] for _ in range(H)]

# ===== Static paint once per map =====
def paint_static_map():
    m = state["map"]
    for y in range(H):
        for x in range(W):
            ch = m[y][x]
            el = cells[y][x]
            el.text = ch
            base_class[y][x] = "cell " + CLASS.get(ch, "t-grass")

# ===== Fog of war =====
def fov_compute():
    """Compute current visMask within radius R (raycast), return set of changed cells vs previous vis."""
    px, py = state["px"], state["py"]
    prev_vis = state["visMask"]
    vis = make_mask(False)
    x0, x1 = max(0, px-R), min(W-1, px+R)
    y0, y1 = max(0, py-R), min(H-1, py+R)
    for y in range(y0, y1+1):
        for x in range(x0, x1+1):
            dx, dy = x-px, y-py
            if dx*dx + dy*dy > R*R: continue
            steps = max(abs(dx), abs(dy))
            stepx = dx/steps if steps else 0
            stepy = dy/steps if steps else 0
            cx, cy = float(px), float(py)
            for _ in range(steps+1):
                ix, iy = int(round(cx)), int(round(cy))
                if not in_bounds(ix,iy): break
                vis[iy][ix] = True
                if is_blocked(state["map"][iy][ix]): break
                cx += stepx; cy += stepy
    for y in range(H):
        for x in range(W):
            if vis[y][x]: state["seenMask"][y][x] = True
    dirty = set()
    if prev_vis is None:
        for y in range(y0, y1+1):
            for x in range(x0, x1+1):
                dirty.add((x,y))
    else:
        for y in range(y0, y1+1):
            for x in range(x0, x1+1):
                if vis[y][x] != prev_vis[y][x]: dirty.add((x,y))
    state["visMask"] = vis
    return dirty

def fog_class_suffix(x,y):
    if not state["fog"]: return ""
    if not state["seenMask"][y][x]: return " fog-unseen"
    if not state["visMask"][y][x]:  return " fog-seen"
    return ""

def paint_fog(dirty_cells, full=False):
    """Apply fog classes to only dirty cells; if full=True, repaint all."""
    if full:
        for y in range(H):
            for x in range(W):
                cells[y][x].class_name = base_class[y][x] + fog_class_suffix(x,y)
        return
    for (x,y) in dirty_cells:
        cells[y][x].class_name = base_class[y][x] + fog_class_suffix(x,y)

# ===== Player paint (respects fog) =====
def paint_player():
    px0, py0 = state["prev_px"], state["prev_py"]
    if in_bounds(px0, py0):
        c0 = cells[py0][px0]
        c0.text = state["map"][py0][px0]
        c0.class_name = base_class[py0][px0] + fog_class_suffix(px0,py0)
    px, py = state["px"], state["py"]
    c1 = cells[py][px]
    c1.class_name = "cell t-player" + fog_class_suffix(px,py)
    c1.text = TILES["PLAYER"]

# ===== Flow =====
maps = []
def msg(s=""): msg_el.text = s

def load_map(idx, place_player):
    state["map"] = maps[idx]
    state["gameOver"] = False
    # spawn at bottom X
    px = 1; py = H-2
    for x in range(1, W-1):
        if state["map"][H-2][x] == 'X':
            px = x; break
    if place_player:
        state["px"], state["py"] = px, py
        state["prev_px"], state["prev_py"] = px, py

    paint_static_map()

    # ---- FOG INIT: paint all unseen, then reveal the ring ----
    if state["fog"]:
        state["seenMask"] = make_mask(False)
        state["visMask"]  = make_mask(False)
        paint_fog(set(), full=True)      # all tiles unseen (black)
        dirty = fov_compute()            # compute current FOV around player
        paint_fog(dirty, full=False)     # update only changed tiles
    else:
        state["seenMask"] = make_mask(True)
        state["visMask"]  = make_mask(True)
        paint_fog(set(), full=True)      # clears fog classes

    paint_player()
    level_el.text = f"Map {idx+1}/{MAPS}"

def init_all():
    global maps
    maps = [gen_trail_map(False), gen_trail_map(False), gen_trail_map(True)]
    state["mapIndex"] = 0
    state["gameOver"] = False
    load_map(state["mapIndex"], True)
    msg("")

def try_move(dx, dy):
    if state["gameOver"]: return
    nx = max(0, min(W-1, state["px"] + dx))
    ny = max(0, min(H-1, state["py"] + dy))
    t = state["map"][ny][nx]
    if is_blocked(t): return
    state["prev_px"], state["prev_py"] = state["px"], state["py"]
    state["px"], state["py"] = nx, ny

    if state["fog"]:
        dirty = fov_compute()
        paint_fog(dirty, full=False)
    else:
        # ensure base restored for previous/current when fog is off
        cells[state["prev_py"]][state["prev_px"]].class_name = base_class[state["prev_py"]][state["prev_px"]]
        cells[ny][nx].class_name = base_class[ny][nx]

    paint_player()

    if t == '➨':
        if state["mapIndex"] < MAPS-1:
            state["mapIndex"] += 1
            msg(f"Advancing to Map {state['mapIndex']+1}...")
            load_map(state["mapIndex"], True); msg("")
    elif t == 'X' and state["py"] == 1 and state["mapIndex"] == MAPS-1:
        msg("You reached the destination! Press R to restart."); state["gameOver"] = True

# ===== Controls =====
@bind(document, "keydown")
def on_keydown(e):
    k = (e.key or "").lower()
    if   k == "w": try_move(0,-1)
    elif k == "s": try_move(0, 1)
    elif k == "a": try_move(-1,0)
    elif k == "d": try_move(1, 0)
    elif k == "r": init_all()
    elif k == "f":
        state["fog"] = not state["fog"]
        if state["fog"]:
            # turning fog on: reset to full unseen, then reveal
            state["seenMask"] = make_mask(False)
            state["visMask"]  = make_mask(False)
            paint_fog(set(), full=True)
            dirty = fov_compute()
            paint_fog(dirty, full=False)
        else:
            # fog off: clear classes across map
            state["seenMask"] = make_mask(True)
            state["visMask"]  = make_mask(True)
            paint_fog(set(), full=True)
        paint_player()

# ===== Boot =====
build_grid_dom()
init_all()
</script>
</body>
</html>
