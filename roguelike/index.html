<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ASCII Roguelike — Fixed Map</title>
  <style>
    :root {
      --bg: #0b0b0b;
      --fg: #e8e6df;       /* near-white for stars & UI */
      --player: #ffd166;
      --panel: #151515;
      --border: #2a2a2a;
      --btn: #1b1b1b;
      --btnBorder: #333;
      --btnHover: #262626;
      /* Palette for fixed map */
      --dark-grey:#6b7280;
      --dark-yellow:#a39e5f;
      --gunmetal:#6f818f;
      --reddish-grey:#a46b6b;
      --dark-sky:#5bc0eb;
      --floor-grey:#383d42;
      --kitchen-green:#6ba46b;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }
    body {
      display: grid;
      place-items: center;
      background: var(--bg);
      color: var(--fg);
      font-family: monospace;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      padding: 10px;
    }

    .wrap { display: grid; gap: 12px; }

    #grid {
      --size: 19;
      display: grid;
      grid-template-columns: repeat(var(--size), 1em);
      grid-auto-rows: 1em;
      gap: 0;
      font-size: 22px;
      line-height: 1;
      user-select: none;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      background: #0e0e0e;
    }
    #grid span { width: 1em; height: 1em; display: inline-block; text-align: center; }
    .player { color: var(--player); font-weight: bold; }

    .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; align-items: start; }
    .dpad { display: grid; grid-template-columns: repeat(3, 48px); grid-template-rows: repeat(3, 48px); gap: 6px; width: max-content; }
    .dpad .spacer { visibility: hidden; }
    .actions { display: flex; justify-content: flex-end; align-items: flex-start; gap: 10px; flex-wrap: wrap; }

    button { background: var(--btn); color: var(--fg); border: 1px solid var(--btnBorder); border-radius: 10px; padding: 10px 14px; cursor: pointer; font: inherit; touch-action: manipulation; }
    button:hover { background: var(--btnHover); }
    .btn-big { padding: 12px 18px; border-radius: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div id="grid" role="application" aria-label="Fixed map"></div>
    <div class="controls" aria-label="Controls">
      <div class="dpad" id="dpad">
        <span class="spacer"></span>
        <button data-dx="0" data-dy="-1">↑</button>
        <span class="spacer"></span>
        <button data-dx="-1" data-dy="0">←</button>
        <span class="spacer"></span>
        <button data-dx="1" data-dy="0">→</button>
        <span class="spacer"></span>
        <button data-dx="0" data-dy="1">↓</button>
        <span class="spacer"></span>
      </div>
      <div class="actions">
        <button id="actionBtn" class="btn-big">Action</button>
      </div>
    </div>
  </div>

  <script>
    const SIZE = 19;

    // Fixed 19x19 environment (spacing preserved)
    const MAP_TEXT = [
      "                   ",
      "                   ",
      "                   ",
      "                   ",
      "        ◢═◣        ",
      "       ◢▦▣▦◣       ",
      "       ║▦□▦║       ",
      "       ║▦□▦║       ",
      "       ║▦□▣║       ",
      "       ║▦□▦║       ",
      "       ◢◩□▦◣       ",
      "      ◢▦□□□▦◣      ",
      "      ║▣□□□▤║      ",
      "      ◥▦▦▦▦▦◤      ",
      "       ◥☰☰☰◤       ",
      "        ☶ ☶        ",
      "                   ",
      "                   ",
      "                   "
    ];

    // Animation frames for blue glyphs at the bottom row
    const ANIM_FRAMES = ['☶', '☵', '☳'];
    let animIndex = 0;
    const animCoords = []; // list of {x, y}

    // Starfield (white '.') in columns 1-6 and 14-19 (1-indexed)
    const STAR_COLS = [0,1,2,3,4,5,13,14,15,16,17,18];
    const STAR_SPEED_MAP = new Map(); // col -> 3 or 4 cells/sec
    const STARS_PER_COL = 1;
    let stars = new Map(); // col -> array of y positions

    let grid = [];
    const player = { x: Math.floor(SIZE/2), y: Math.floor(SIZE/2) };

    const getCSS = (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim();

    const colorFor = (ch) => {
      if (ch === '.') return getCSS('--fg');   // stars are white
      if (ch === '▤') return getCSS('--dark-yellow');
      if (ch === '□') return getCSS('--floor-grey');
      if (ch === '◩') return getCSS('--kitchen-green');
      if (ch === '▦') return getCSS('--gunmetal');
      if (ch === '▣') return getCSS('--reddish-grey');
      if ("◢◣◥◤║═".includes(ch)) return getCSS('--gunmetal');
      if ("☰☶☵☳".includes(ch)) return getCSS('--dark-sky');
      return getCSS('--floor-grey');
    };

    // Passability rules
    const isPassable = (ch) => ch === '.' || ch === '□' || ch === '▣' || ch === '◩' || ch === '▤';

    function loadMap() {
      grid = MAP_TEXT.map(row => row.padEnd(SIZE, ' ').slice(0, SIZE).split(''));

      // Record animated cell coordinates (any of the anim set)
      for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) {
          if ('☶☵☳'.includes(grid[y][x])) animCoords.push({ x, y });
        }
      }
      // Normalize starting frame
      for (const {x, y} of animCoords) grid[y][x] = ANIM_FRAMES[0];

      // Init starfield
      initStars();

      // Ensure player starts on a passable tile; if center blocked, find nearest
      if (!isPassable(grid[player.y][player.x])) {
        outer: for (let r = 0; r < SIZE; r++) {
          for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
              const xx = player.x + dx, yy = player.y + dy;
              if (xx>=0&&xx<SIZE&&yy>=0&&yy<SIZE && isPassable(grid[yy][xx])) { player.x=xx; player.y=yy; break outer; }
            }
          }
        }
      }
      render();
      startBlueAnim();
      startStarfield();
    }

    function initStars() {
      // assign speeds alternating 3 and 4 cells/sec
      STAR_COLS.forEach((col, i) => {
        STAR_SPEED_MAP.set(col, (i % 2 === 0) ? 2 : 4);
        const ys = [];
        // seed a few star rows randomly where background is space
        while (ys.length < STARS_PER_COL) {
          const y = Math.floor(Math.random() * SIZE);
          if (grid[y][col] === ' ' && !ys.includes(y)) ys.push(y);
        }
        stars.set(col, ys);
      });
    }

    function startBlueAnim() {
      setInterval(() => {
        animIndex = (animIndex + 1) % ANIM_FRAMES.length;
        for (const {x, y} of animCoords) grid[y][x] = ANIM_FRAMES[animIndex];
        render();
      }, 1000);
    }

    function startStarfield() {
      // timer for columns at 4 cells/sec
      setInterval(() => {
        advanceStars((col) => STAR_SPEED_MAP.get(col) === 4);
      }, 250);
      // timer for columns at 3 cells/sec
      setInterval(() => {
        advanceStars((col) => STAR_SPEED_MAP.get(col) === 2);
      }, 333);
    }

    function advanceStars(predicate) {
      let moved = false;
      for (const col of STAR_COLS) {
        if (!predicate(col)) continue;
        const ys = stars.get(col) || [];
        for (let i = 0; i < ys.length; i++) {
          // move down one row; wrap; keep to space-only lanes
          let ny = (ys[i] + 1) % SIZE;
          // if wrapped or blocked by hull, try to find next space row
          let guard = 0;
          while (grid[ny][col] !== ' ' && guard++ < SIZE) ny = (ny + 1) % SIZE;
          ys[i] = ny;
        }
        stars.set(col, ys);
        moved = true;
      }
      if (moved) render();
    }

    function cellHTML(x, y) {
      if (player.x === x && player.y === y) return '<span class="player">@</span>';

      // Star overlay: if this coordinate is a star (and base is space), draw white '.'
      if (grid[y][x] === ' ' && STAR_COLS.includes(x)) {
        const ys = stars.get(x);
        if (ys && ys.includes(y)) return `<span style="color:${getCSS('--fg')}">.</span>`;
      }

      const ch = grid[y][x];
      const color = colorFor(ch);
      const glyph = ch === ' ' ? ' ' : ch;
      return `<span style="color:${color}">${glyph}</span>`;
    }

    function tryMove(dx, dy) {
      const nx = player.x + dx, ny = player.y + dy;
      if (nx < 0 || ny < 0 || nx >= SIZE || ny >= SIZE) return;
      const target = grid[ny][nx];
      if (!isPassable(target)) return;
      player.x = nx; player.y = ny;
      render();
    }

    function render() {
      const el = document.getElementById('grid');
      const out = [];
      for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) out.push(cellHTML(x, y));
      }
      el.innerHTML = out.join('');
    }

    function doAction() { /* placeholder */ }

    // Input
    document.addEventListener('keydown', e => {
      const keyMap = { 'ArrowUp':[0,-1], 'ArrowDown':[0,1], 'ArrowLeft':[-1,0], 'ArrowRight':[1,0], 'w':[0,-1], 'a':[-1,0], 's':[0,1], 'd':[1,0], 'W':[0,-1], 'A':[-1,0], 'S':[0,1], 'D':[1,0] };
      if (keyMap[e.key]) { e.preventDefault(); const [dx, dy] = keyMap[e.key]; tryMove(dx, dy); }
      else if (e.key === ' ') { e.preventDefault(); doAction(); }
    });

    document.getElementById('dpad').addEventListener('click', e => { const btn = e.target.closest('button[data-dx]'); if (!btn) return; tryMove(parseInt(btn.dataset.dx, 10), parseInt(btn.dataset.dy, 10)); });
    document.getElementById('actionBtn').addEventListener('click', doAction);

    loadMap();
  </script>
</body>
</html>
