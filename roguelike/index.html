<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ASCII Roguelike — Fixed Map</title>
  <style>
    :root {
      --bg: #0b0b0b;
      --fg: #e8e6df;
      --player: #ffd166;
      --panel: #151515;
      --border: #a39e5f;
      --btn: #1b1b1b;
      --btnBorder: #a39e5f;
      --btnHover: #a39e5f;

      --dark-grey:#6b7280;
      --dark-yellow:#a39e5f;
      --gunmetal:#6f818f;
      --reddish-grey:#a46b6b;
      --blueish-grey:#6b7ca4;
      --purplish-grey:#8c6ba4;
      --dark-sky:#5bc0eb;
      --floor-grey:#383d42;
      --kitchen-green:#6ba46b;
      --hover: rgba(255,255,255,0.09); /* subtle overlay highlight */
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; width: 100%; margin: 0; }
    body {
      display: grid;
      place-items: center;
      background: var(--bg);
      color: var(--fg);
      font-family: monospace;
      -webkit-font-smoothing: None;
      -moz-osx-font-smoothing: None;
      padding: 0px;
    }

    .wrap { display: grid; gap: 14px; }

    #grid {
      --size: 19;
      display: grid;
      grid-template-columns: repeat(var(--size), 1em);
      grid-auto-rows: 1em;
      gap: 0px;
      /* Make the grid fit the screen width/height dynamically */
      font-size: min(22px); /* scales with viewport */
      line-height: 1;
      user-select: none;
      border: 1px dashed var(--border);
      border-radius: 15px;
      padding: 0px;
      background: #0e0e0e;
    }
    #grid span { width: 1em; height: 1em; display: inline-block; text-align: center; }
    .player { color: var(--player); font-weight: bold; }

    .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; align-items: start; }
    .dpad { display: grid; margin-left: 30px; grid-template-columns: repeat(3, 48px); grid-template-rows: repeat(3, 48px); gap: 0px; width: max-content; }
    .dpad .spacer { visibility: hidden; }
    .actions { display: grid; justify-content: flex-end; align-items: flex-start; gap: 10px; flex-wrap: wrap; }

    button { background: var(--btn); color: #a39e5f; border: 1px dashed var(--btnBorder); border-radius: 10px; padding: 12px 18px; cursor: pointer; font: inherit; }
    button:hover { background: var(--btnHover); color: black; }
    .btn-big { margin-right: 60px; margin-top: 12px; padding: 17px 21px; border-radius: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div id="grid" role="application" aria-label="Fixed map"></div>
    <div class="controls" aria-label="Controls">
      <div class="dpad" id="dpad">
        <span class="spacer"></span>
        <button data-dx="0" data-dy="-1">↑</button>
        <span class="spacer"></span>
        <button data-dx="-1" data-dy="0">←</button>
        <span class="spacer"></span>
        <button data-dx="1" data-dy="0">→</button>
        <span class="spacer"></span>
        <button data-dx="0" data-dy="1">↓</button>
        <span class="spacer"></span>
      </div>
      <div class="actions">
        <button id="actionBtn" class="btn-big">A</button>
        <button id="cancelBtn" class="btn-big">B</button>
      </div>
    </div>
  </div>

  <script>
    const SIZE = 19;

    // Fixed 19x19 environment (spacing preserved)
    const MAP_TEXT = [
      "                   ",
      "                   ",
      "                   ",
      "                   ",
      "        ◢═◣        ",
      "       ◢▦▣▦◣       ",
      "       ║▦□▦║       ",
      "       ║▦□▦║       ",
      "       ║▦□▨║       ",
      "       ║▦□▦║       ",
      "       ◢◩□▦◣       ",
      "      ◢▦□□□▦◣      ",
      "      ║▩□□□▤║      ",
      "      ◥▦▦▦▦▦◤      ",
      "       ◥☰☰☰◤       ",
      "        ☶ ☶        ",
      "                   ",
      "                   ",
      "                   "
    ];

    // Exhaust animation frames (blue)
    const ANIM_FRAMES = ['☶', '☵', '☳'];
    let animIndex = 0;

    // Starfield (white '.') in columns 1-6 and 14-19 (1-indexed)
    const STAR_COLS = [0,1,2,3,4,5,13,14,15,16,17,18];
    const STAR_SPEED_MAP = new Map(); // col -> 3 or 4 cells/sec
    const STARS_PER_COL = 1;
    let stars = new Map();            // col -> array<number> y positions

    let grid = [];
    let enginesOn = true; // starfield + exhaust animation state

    // Overlay prompt state (centered dashed box)
    // type: 'engines' | 'message'
    let overlay = { open: false, x: 0, y: 0, w: SIZE, h: SIZE, type: 'engines', textLines: [] };

    // Hover state for subtle highlight & pointer cursor (engines overlay only)
    let hover = { x: -1, y: -1, overClickable: false, overOff: true };

    const player = { x: Math.floor(SIZE/2), y: Math.floor(SIZE/2) };

    const getCSS = (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim();

    const colorFor = (ch) => {
      if (ch === '.') return getCSS('--fg');   // stars are white
      if (ch === '▤') return getCSS('--dark-yellow');
      if (ch === '□') return getCSS('--floor-grey');
      if (ch === '◩') return getCSS('--kitchen-green');
      if (ch === '▦') return getCSS('--gunmetal');
      if (ch === '▣') return getCSS('--reddish-grey');
      if (ch === '▨') return getCSS('--blueish-grey');
      if (ch === '▩') return getCSS('--purplish-grey');
      if ("◢◣◥◤║═".includes(ch)) return getCSS('--gunmetal');
      if ("☰☶☵☳".includes(ch)) return getCSS('--dark-sky');
      return getCSS('--floor-grey');
    };

    // Passability rules
    const isPassable = (ch) =>
      ch === '.' || ch === '□' || ch === '▣' || ch === '◩' || ch === '▤' || ch === '▩' || ch === '▨';

    function loadMap() {
      grid = MAP_TEXT.map(row => row.padEnd(SIZE, ' ').slice(0, SIZE).split(''));
      initStars();
      ensurePlayerOnPassable();
      render();
      startBlueAnim();
      startStarfield();
    }

    function ensurePlayerOnPassable() {
      if (!isPassable(grid[player.y][player.x])) {
        outer: for (let r = 0; r < SIZE; r++) {
          for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
              const xx = player.x + dx, yy = player.y + dy;
              if (xx>=0&&xx<SIZE&&yy>=0&&yy<SIZE && isPassable(grid[yy][xx])) { player.x=xx; player.y=yy; break outer; }
            }
          }
        }
      }
    }

    function initStars() {
      // Alternate speeds: 3 and 4 cells/sec
      STAR_COLS.forEach((col, i) => {
        STAR_SPEED_MAP.set(col, (i % 2 === 0) ? 3 : 4);
        const ys = [];
        while (ys.length < STARS_PER_COL) {
          const y = Math.floor(Math.random() * SIZE);
          if (grid[y][col] === ' ' && !ys.includes(y)) ys.push(y);
        }
        stars.set(col, ys);
      });
    }

    function startBlueAnim() {
      setInterval(() => {
        if (overlay.open || !enginesOn) return; // pause while overlay open or engines off
        animIndex = (animIndex + 1) % ANIM_FRAMES.length;
        render();
      }, 1000);
    }

    function startStarfield() {
      // 4 cells/sec -> tick every 250ms
      setInterval(() => {
        if (!overlay.open && enginesOn) advanceStars(col => STAR_SPEED_MAP.get(col) === 4);
      }, 250);
      // 3 cells/sec -> tick every ~333ms
      setInterval(() => {
        if (!overlay.open && enginesOn) advanceStars(col => STAR_SPEED_MAP.get(col) === 3);
      }, 333);
    }

    function advanceStars(predicate) {
      let moved = false;
      for (const col of STAR_COLS) {
        if (!predicate(col)) continue;
        const ys = stars.get(col) || [];
        for (let i = 0; i < ys.length; i++) {
          let ny = (ys[i] + 1) % SIZE; // move down, wrap
          // keep to space lanes (skip hull)
          let guard = 0;
          while (grid[ny][col] !== ' ' && guard++ < SIZE) ny = (ny + 1) % SIZE;
          ys[i] = ny;
        }
        stars.set(col, ys);
        moved = true;
      }
      if (moved) render();
    }

    // --- Overlay helpers ---
    function openOverlay(type, opts = {}) {
      overlay.open = true;
      overlay.type = type;
      if (type === 'message') {
        const text = opts.text || '';
        overlay.textLines = wrapText(text, overlay.w - 2); // padding: 2 chars per side
      } else {
        overlay.textLines = [];
      }
      render();
    }
    function closeOverlay() { overlay.open = false; render(); }
    function wrapText(text, maxWidth) {
      const words = text.split(/\s+/);
      const lines = [];
      let line = '';
      for (const w of words) {
        if (!line.length) { line = w; continue; }
        if ((line.length + 1 + w.length) <= maxWidth) line += ' ' + w;
        else { lines.push(line); line = w; }
      }
      if (line) lines.push(line);
      return lines;
    }

    function cellHTML(x, y) {
      // 1) Overlay prompt overrides everything in its rect
      if (overlay.open) {
        if (x >= overlay.x && x < overlay.x + overlay.w && y >= overlay.y && y < overlay.y + overlay.h) {
          const relX = x - overlay.x, relY = y - overlay.y;
          const isBorder = (relY === 0 || relY === overlay.h - 1 || relX === 0 || relX === overlay.w - 1);
          if (isBorder) {
            const corner = (relX === 0 || relX === overlay.w - 1) && (relY === 0 || relY === overlay.h - 2);
            if (corner) return `<span data-x="${x}" data-y="${y}" style="color:${getCSS('--kitchen-green')}">·</span>`;
            const dash = (relY === 0 || relY === overlay.h - 0)
              ? (relX % 0 === 0 ? '─' : ' ')
              : (relY % 0 === 0 ? '│' : ' ');
            return `<span data-x="${x}" data-y="${y}" style="color:${getCSS('--kitchen-green')}">·</span>`;
          }

          if (overlay.type === 'message') {
            // center message lines, with 2-char left/right padding
            const startY = Math.max(1, Math.floor((overlay.h - overlay.textLines.length) / 2));
            const contentY = relY - startY;
            if (contentY >= 0 && contentY < overlay.textLines.length && relX >= 0 && relX < overlay.w - 1) {
              const line = overlay.textLines[contentY];
              const idx = relX - 1;
              const ch = (idx >= 0 && idx < line.length) ? line[idx] : '';
              return `<span data-x="${x}" data-y="${y}" style="color:${getCSS('--dark-yellow')}">${ch}</span>`;
            }
            return `<span data-x="${x}" data-y="${y}"> </span>`;
          }

          // engines overlay (OFF/ON)
          const mid = Math.floor(overlay.h/2);
          if (relY === mid) {
            const OFF = 'OFF', ON = 'ON';
            const offStart = 3;
            const onStart = overlay.w - ON.length - 3;

            // padded clickable ranges
            const offMin = Math.max(1, offStart - 2);
            const offMax = Math.min(overlay.w - 2, offStart + OFF.length + 2);
            const onMin  = Math.max(1, onStart  - 2);
            const onMax  = Math.min(overlay.w - 2, onStart  + ON.length  + 2);

            const inOff = relX >= offMin && relX < offMax;
            const inOn  = relX >= onMin  && relX < onMax;
            // If hovering any part of a band, highlight that whole band
            const shouldHighlight = hover.overClickable && ((hover.overOff && inOff) || (!hover.overOff && inOn));
            const bg = shouldHighlight ? `` : '';

            // draw OFF letters
            if (relX >= offStart && relX < offStart + OFF.length) {
              return `<span data-x="${x}" data-y="${y}" style="color:${getCSS('--fg')}${bg}">${OFF[relX - offStart]}</span>`;
            }
            // draw ON letters
            if (relX >= onStart && relX < onStart + ON.length) {
              return `<span data-x="${x}" data-y="${y}" style="color:${getCSS('--fg')}${bg}">${ON[relX - onStart]}</span>`;
            }
            // inside clickable padding area: show highlight when hovered
            if (inOff || inOn) {
              return `<span data-x="${x}" data-y="${y}"> </span>`;
            }
          }
          return `<span data-x="${x}" data-y="${y}"> </span>`;
        }
      }

      // 2) Player on top of base map & stars
      if (player.x === x && player.y === y) return `<span data-x="${x}" data-y="${y}" class="player">@</span>`;

      // 3) Stars overlay: only on empty space cells
      if (grid[y][x] === ' ' && STAR_COLS.includes(x)) {
        const ys = stars.get(x);
        if (ys && ys.includes(y)) return `<span data-x="${x}" data-y="${y}" style="color:${getCSS('--fg')}">.</span>`;
      }

      // 4) Engine exhaust overlay (animate when engines ON, blank when OFF)
      const baseCh = grid[y][x];
      if ('☶☵☳'.includes(baseCh)) {
        if (enginesOn) {
          const ch = ANIM_FRAMES[animIndex];
          return `<span data-x="${x}" data-y="${y}" style="color:${getCSS('--dark-sky')}">${ch}</span>`;
        }
        return `<span data-x="${x}" data-y="${y}"> </span>`;
      }

      // 5) Base map
      const color = colorFor(baseCh);
      const glyph = baseCh === ' ' ? ' ' : baseCh;
      return `<span data-x="${x}" data-y="${y}" style="color:${color}">${glyph}</span>`;
    }

    function tryMove(dx, dy) {
      if (overlay.open) return; // ignore movement while prompt is open
      const nx = player.x + dx, ny = player.y + dy;
      if (nx < 0 || ny < 0 || nx >= SIZE || ny >= SIZE) return;
      const target = grid[ny][nx];
      if (!isPassable(target)) return;
      player.x = nx; player.y = ny;
      render();
    }

    function render() {
      const el = document.getElementById('grid');
      const out = [];
      for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) out.push(cellHTML(x, y));
      }
      el.innerHTML = out.join('');

      // Cursor feedback for clickable region (engines overlay only)
      if (overlay.open && overlay.type === 'engines' && hover.overClickable) {
        el.style.cursor = 'pointer';
      } else {
        el.style.cursor = '';
      }
    }

    function doAction() {
      // Standing on control tiles:
      // ▩ = engines prompt; ▨ = message prompt
      const ch = grid[player.y][player.x];
      if (ch === '▩') {
        openOverlay('engines');
      } else if (ch === '▨') {
        openOverlay('message', {
          text: "You peer into the endless expanse. Sensors read as normal, but none of these star systems appear on the ship's many star charts."
        });
      }
    }

    // Input
    document.addEventListener('keydown', e => {
      if (overlay.open) {
        // Common dismiss keys
        if (e.key === 'Escape' || e.key === 'Enter') { closeOverlay(); return; }
        // Engines overlay hotkeys
        if (overlay.type === 'engines') {
          if (e.key.toLowerCase() === 'o') { enginesOn = false; closeOverlay(); return; }
          if (e.key.toLowerCase() === 'n') { enginesOn = true;  closeOverlay(); return; }
        }
        return; // ignore other keys while overlay is open
      }
      const keyMap = {
        'ArrowUp':[0,-1], 'ArrowDown':[0,1], 'ArrowLeft':[-1,0], 'ArrowRight':[1,0],
        'w':[0,-1], 'a':[-1,0], 's':[0,1], 'd':[1,0],
        'W':[0,-1], 'A':[-1,0], 'S':[0,1], 'D':[1,0]
      };
      if (keyMap[e.key]) { e.preventDefault(); const [dx, dy] = keyMap[e.key]; tryMove(dx, dy); }
      else if (e.key === ' ') { e.preventDefault(); doAction(); }
    });

    // D-pad & Action button
    document.getElementById('dpad').addEventListener('click', e => {
      if (overlay.open) return;
      const btn = e.target.closest('button[data-dx]');
      if (!btn) return;
      tryMove(parseInt(btn.dataset.dx, 10), parseInt(btn.dataset.dy, 10));
    });
    document.getElementById('actionBtn').addEventListener('click', doAction);
    document.getElementById('cancelBtn').addEventListener('click', closeOverlay)

    // Hover highlight & selection inside overlay (engines overlay only)
    const gridEl = document.getElementById('grid');

    gridEl.addEventListener('mousemove', (e) => {
      const span = e.target.closest('span[data-x]');
      if (!span) { hover = { x:-1, y:-1, overClickable:false, overOff:false }; render(); return; }
      const x = parseInt(span.getAttribute('data-x'), 10);
      const y = parseInt(span.getAttribute('data-y'), 10);
      hover.x = x; hover.y = y; hover.overClickable = false; hover.overOff = false;

      if (overlay.open && overlay.type === 'engines'
          && x >= overlay.x && x < overlay.x + overlay.w
          && y >= overlay.y && y < overlay.y + overlay.h) {
        const relX = x - overlay.x, relY = y - overlay.y;
        const mid = Math.floor(overlay.h/2);
        if (relY === mid) {
          const OFF = 'OFF', ON = 'ON';
          const offStart = 3;
          const onStart = overlay.w - ON.length - 2;
          const offMin = Math.max(1, offStart - 2);
          const offMax = Math.min(overlay.w - 2, offStart + OFF.length + 2);
          const onMin  = Math.max(1, onStart  - 2);
          const onMax  = Math.min(overlay.w - 2, onStart  + ON.length  + 2);
          if (relX >= offMin && relX < offMax) { hover.overClickable = true; hover.overOff = true; }
          else if (relX >= onMin  && relX < onMax)  { hover.overClickable = true; hover.overOff = false; }
        }
      }
      render();
    });

    gridEl.addEventListener('mouseleave', () => {
      hover = { x:-1, y:-1, overClickable:false, overOff:true };
      render();
    });

    // Use pointerdown so we act before any repaint
    gridEl.addEventListener('pointerdown', (e) => {
      if (!overlay.open) return;
      const span = e.target.closest('span[data-x]');
      if (!span) return;
      const x = parseInt(span.getAttribute('data-x'), 10);
      const y = parseInt(span.getAttribute('data-y'), 10);
      if (!(x >= overlay.x && x < overlay.x + overlay.w && y >= overlay.y && y < overlay.y + overlay.h)) return;

      const relX = x - overlay.x, relY = y - overlay.y;
      const mid = Math.floor(overlay.h/2);

      if (overlay.type === 'engines') {
        if (relY !== mid) return; // only middle line clickable
        const OFF = 'OFF', ON = 'ON';
        const offStart = 3;
        const onStart = overlay.w - ON.length - 3;
        const offMin = Math.max(1, offStart - 2);
        const offMax = Math.min(overlay.w - 2, offStart + OFF.length + 2);
        const onMin  = Math.max(1, onStart  - 2);
        const onMax  = Math.min(overlay.w - 2, onStart  + ON.length  + 2);
        if (relX >= offMin && relX < offMax) { enginesOn = false; closeOverlay(); return; }
        if (relX >= onMin  && relX < onMax)  { enginesOn = true;  closeOverlay(); return; }
        // Fallback by side if between bands
        if (relX < Math.floor(overlay.w / 2)) { enginesOn = false; closeOverlay(); }
        else { enginesOn = true; closeOverlay(); }
      } else if (overlay.type === 'message') {
        // Any click inside closes the message box
        closeOverlay();
      }
    });

    loadMap();
  </script>
</body>
</html>
